# [17136] ë¬¸ì œì œëª©

### **ë‚œì´ë„**
ê³¨ë“œ 2
## **ğŸ“ë¬¸ì œ**
<ê·¸ë¦¼ 1>ê³¼ ê°™ì´ ì •ì‚¬ê°í˜• ëª¨ì–‘ì„ í•œ ë‹¤ì„¯ ì¢…ë¥˜ì˜ ìƒ‰ì¢…ì´ê°€ ìˆë‹¤. ìƒ‰ì¢…ì´ì˜ í¬ê¸°ëŠ” 1Ã—1, 2Ã—2, 3Ã—3, 4Ã—4, 5Ã—5ë¡œ ì´ ë‹¤ì„¯ ì¢…ë¥˜ê°€ ìˆìœ¼ë©°, ê° ì¢…ë¥˜ì˜ ìƒ‰ì¢…ì´ëŠ” 5ê°œì”© ê°€ì§€ê³  ìˆë‹¤.



<ê·¸ë¦¼ 1>

ìƒ‰ì¢…ì´ë¥¼ í¬ê¸°ê°€ 10Ã—10ì¸ ì¢…ì´ ìœ„ì— ë¶™ì´ë ¤ê³  í•œë‹¤. ì¢…ì´ëŠ” 1Ã—1 í¬ê¸°ì˜ ì¹¸ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆìœ¼ë©°, ê°ê°ì˜ ì¹¸ì—ëŠ” 0 ë˜ëŠ” 1ì´ ì í˜€ ìˆë‹¤. 1ì´ ì íŒ ì¹¸ì€ ëª¨ë‘ ìƒ‰ì¢…ì´ë¡œ ë®ì—¬ì ¸ì•¼ í•œë‹¤. ìƒ‰ì¢…ì´ë¥¼ ë¶™ì¼ ë•ŒëŠ” ì¢…ì´ì˜ ê²½ê³„ ë°–ìœ¼ë¡œ ë‚˜ê°€ì„œëŠ” ì•ˆë˜ê³ , ê²¹ì³ë„ ì•ˆ ëœë‹¤. ë˜, ì¹¸ì˜ ê²½ê³„ì™€ ì¼ì¹˜í•˜ê²Œ ë¶™ì—¬ì•¼ í•œë‹¤. 0ì´ ì íŒ ì¹¸ì—ëŠ” ìƒ‰ì¢…ì´ê°€ ìˆìœ¼ë©´ ì•ˆ ëœë‹¤.

ì¢…ì´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, 1ì´ ì íŒ ëª¨ë“  ì¹¸ì„ ë¶™ì´ëŠ”ë° í•„ìš”í•œ ìƒ‰ì¢…ì´ì˜ ìµœì†Œ ê°œìˆ˜ë¥¼ êµ¬í•´ë³´ì.
### **ì…ë ¥**
ì´ 10ê°œì˜ ì¤„ì— ì¢…ì´ì˜ ê° ì¹¸ì— ì íŒ ìˆ˜ê°€ ì£¼ì–´ì§„ë‹¤.

### **ì¶œë ¥**
ëª¨ë“  1ì„ ë®ëŠ”ë° í•„ìš”í•œ ìƒ‰ì¢…ì´ì˜ ìµœì†Œ ê°œìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤. 1ì„ ëª¨ë‘ ë®ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ì—ëŠ” -1ì„ ì¶œë ¥í•œë‹¤.

### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

**ì˜ˆì œ ì¶œë ¥1**

```
0
```

**ì˜ˆì œ ì…ë ¥2**

```
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

**ì˜ˆì œ ì¶œë ¥2**

```
4
```

**ì˜ˆì œ ì…ë ¥3**

```
0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

**ì˜ˆì œ ì¶œë ¥3**

```
5
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
def can_attach(x, y, size):
    # ì£¼ì–´ì§„ ìœ„ì¹˜ (x, y)ì—ì„œ í¬ê¸° sizeì˜ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì¼ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
    if x + size > 10 or y + size > 10:
        return False
    for i in range(size):
        for j in range(size):
            if table[x + i][y + j] != 1 or visited[x + i][y + j]:
                return False
    return True

def attach(x, y, size, flag):
    # ì£¼ì–´ì§„ ìœ„ì¹˜ (x, y)ì— í¬ê¸° sizeì˜ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì´ê±°ë‚˜ ë–¼ê¸° (flag: True ë¶™ì´ê¸°, False ë–¼ê¸°)
    for i in range(size):
        for j in range(size):
            visited[x + i][y + j] = flag

def dfs(cnt):
    global min_count
    if cnt >= min_count:
        return
    # ëª¨ë“  1ì´ ë®ì˜€ëŠ”ì§€ í™•ì¸
    if all(all(visited[i][j] or table[i][j] == 0 for j in range(10)) for i in range(10)):
        min_count = min(min_count, cnt)
        return

    for i in range(10):
        for j in range(10):
            if table[i][j] == 1 and not visited[i][j]:
                for size in range(5, 0, -1):
                    if used[size] < 5 and can_attach(i, j, size):
                        attach(i, j, size, True)
                        used[size] += 1
                        dfs(cnt + 1)
                        attach(i, j, size, False)
                        used[size] -= 1
                return

table = [list(map(int, input().split())) for _ in range(10)]
visited = [[False] * 10 for _ in range(10)]
used = [0] * 6
min_count = float('inf')

dfs(0)
print(-1 if min_count == float('inf') else min_count)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|31120|3528|Python3|1517
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë°±íŠ¸ë˜í‚¹
```
### **ë‹¤ë¥¸ í’€ì´**

```python
import sys
input = sys.stdin.readline

def checkcheck(r, c, count):
    global paper_count, failed
    if count >= paper_count:
        return
    
    if r == 10:
        if count < paper_count:
            paper_count = count
        return
    if c == 0:
        col_check = 0
        for i in range(10):
            if board[r][i]:
                col_check |= 1<<i
        
        if str(papers) in dp[r][col_check]:
            if dp[r][col_check][str(papers)] > count:
                dp[r][col_check][str(papers)] = count
            else:
                return
        else:
            dp[r][col_check][str(papers)] = count
            
    elif c == 10:
        checkcheck(r+1, 0, count)
        return
    
    marked = is_marked(r,c)
    if marked:
        for i in range(1, marked+1):
            if papers[i-1]>0:
                mark(r,c,i,0)
                papers[i-1]-=1
                checkcheck(r,c+i,count+1)
                mark(r,c,i,1)
                papers[i-1]+=1
            else:
                failed = True
    else:
        checkcheck(r,c+1,count)
    return


def is_marked(r,c):
    if board[r][c]:
        if r < 6 and c < 6:
            if sum([sum(board[r+i][c:c+5]) for i in range(5)]) == 25:
                return 5
        if r < 7 and c < 7:
            if sum([sum(board[r+i][c:c+4]) for i in range(4)]) == 16:
                return 4
        if r < 8 and c < 8:
            if sum([sum(board[r+i][c:c+3]) for i in range(3)]) == 9:
                return 3
        if r < 9 and c < 9:
            if sum([sum(board[r+i][c:c+2]) for i in range(2)]) == 4:
                return 2
        return 1
    else:
        return 0

def mark(r,c,size, flag):
    for dr in range(size):
        for dc in range(size):
            board[r+dr][c+dc] = flag
   

board = [list(map(int,input().split())) for _ in range(10)]
papers = [5,5,5,5,5]
dp = [[{} for _ in range(1024)] for _ in range(10)]
paper_count = 30
failed = False
checkcheck(0,0,0)
if paper_count == 30:
    paper_count = 0
if not paper_count and failed:
    print(-1)
else:
    print(paper_count)
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
toto9091|30476|236|Python3|2097
#### **ğŸ“í•´ì„¤**

```python
def can_attach(x, y, size):
    # ì£¼ì–´ì§„ ìœ„ì¹˜ (x, y)ì—ì„œ í¬ê¸° sizeì˜ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì¼ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
    if x + size > 10 or y + size > 10:
        return False
    for i in range(size):
        for j in range(size):
            if table[x + i][y + j] != 1 or visited[x + i][y + j]:
                return False
    return True

def attach(x, y, size, flag):
    # ì£¼ì–´ì§„ ìœ„ì¹˜ (x, y)ì— í¬ê¸° sizeì˜ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì´ê±°ë‚˜ ë–¼ê¸° (flag: True ë¶™ì´ê¸°, False ë–¼ê¸°)
    for i in range(size):
        for j in range(size):
            visited[x + i][y + j] = flag

def dfs(cnt):
    global min_count
    if cnt >= min_count:
        return
    # ëª¨ë“  1ì´ ë®ì˜€ëŠ”ì§€ í™•ì¸
    if all(all(visited[i][j] or table[i][j] == 0 for j in range(10)) for i in range(10)):
        min_count = min(min_count, cnt)
        return

    for i in range(10):
        for j in range(10):
            if table[i][j] == 1 and not visited[i][j]:
                for size in range(5, 0, -1):
                    if used[size] < 5 and can_attach(i, j, size):
                        attach(i, j, size, True)
                        used[size] += 1
                        dfs(cnt + 1)
                        attach(i, j, size, False)
                        used[size] -= 1
                return

table = [list(map(int, input().split())) for _ in range(10)]
visited = [[False] * 10 for _ in range(10)]
used = [0] * 6
min_count = float('inf')

dfs(0)
print(-1 if min_count == float('inf') else min_count)
```