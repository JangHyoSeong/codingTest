# [5427] ë¶ˆ

### **ë‚œì´ë„**
ê³¨ë“œ 4
## **ğŸ“ë¬¸ì œ**
ìƒê·¼ì´ëŠ” ë¹ˆ ê³µê°„ê³¼ ë²½ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ê±´ë¬¼ì— ê°‡í˜€ìˆë‹¤. ê±´ë¬¼ì˜ ì¼ë¶€ì—ëŠ” ë¶ˆì´ ë‚¬ê³ , ìƒê·¼ì´ëŠ” ì¶œêµ¬ë¥¼ í–¥í•´ ë›°ê³  ìˆë‹¤.

ë§¤ ì´ˆë§ˆë‹¤, ë¶ˆì€ ë™ì„œë‚¨ë¶ ë°©í–¥ìœ¼ë¡œ ì¸ì ‘í•œ ë¹ˆ ê³µê°„ìœ¼ë¡œ í¼ì ¸ë‚˜ê°„ë‹¤. ë²½ì—ëŠ” ë¶ˆì´ ë¶™ì§€ ì•ŠëŠ”ë‹¤. ìƒê·¼ì´ëŠ” ë™ì„œë‚¨ë¶ ì¸ì ‘í•œ ì¹¸ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìœ¼ë©°, 1ì´ˆê°€ ê±¸ë¦°ë‹¤. ìƒê·¼ì´ëŠ” ë²½ì„ í†µê³¼í•  ìˆ˜ ì—†ê³ , ë¶ˆì´ ì˜®ê²¨ì§„ ì¹¸ ë˜ëŠ” ì´ì œ ë¶ˆì´ ë¶™ìœ¼ë ¤ëŠ” ì¹¸ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ë‹¤. ìƒê·¼ì´ê°€ ìˆëŠ” ì¹¸ì— ë¶ˆì´ ì˜®ê²¨ì˜´ê³¼ ë™ì‹œì— ë‹¤ë¥¸ ì¹¸ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆë‹¤.

ë¹Œë”©ì˜ ì§€ë„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì–¼ë§ˆë‚˜ ë¹¨ë¦¬ ë¹Œë”©ì„ íƒˆì¶œí•  ìˆ˜ ìˆëŠ”ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
### **ì…ë ¥**
ì²«ì§¸ ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜ê°€ ì£¼ì–´ì§„ë‹¤. í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ëŠ” ìµœëŒ€ 100ê°œì´ë‹¤.

ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ì²«ì§¸ ì¤„ì—ëŠ” ë¹Œë”© ì§€ë„ì˜ ë„ˆë¹„ì™€ ë†’ì´ wì™€ hê°€ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ w,h â‰¤ 1000)

ë‹¤ìŒ hê°œ ì¤„ì—ëŠ” wê°œì˜ ë¬¸ì, ë¹Œë”©ì˜ ì§€ë„ê°€ ì£¼ì–´ì§„ë‹¤.

- '.': ë¹ˆ ê³µê°„
- '#': ë²½
- '@': ìƒê·¼ì´ì˜ ì‹œì‘ ìœ„ì¹˜
- '*': ë¶ˆ  
ê° ì§€ë„ì— @ì˜ ê°œìˆ˜ëŠ” í•˜ë‚˜ì´ë‹¤.
### **ì¶œë ¥**
ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤ ë¹Œë”©ì„ íƒˆì¶œí•˜ëŠ”ë° ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì„ ì¶œë ¥í•œë‹¤. ë¹Œë”©ì„ íƒˆì¶œí•  ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ëŠ” "IMPOSSIBLE"ì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
5
4 3
####
#*@.
####
7 6
###.###
#*#.#*#
#.....#
#.....#
#..@..#
#######
7 4
###.###
#....*#
#@....#
.######
5 5
.....
.***.
.*@*.
.***.
.....
3 3
###
#@#
###
```

**ì˜ˆì œ ì¶œë ¥1**

```
2
5
IMPOSSIBLE
IMPOSSIBLE
IMPOSSIBLE
```

### **ì¶œì²˜**
ICPC > Regionals > Europe > Northwestern European Regional Contest > Benelux Algorithm Programming Contest > BAPC 2012 Fë²ˆ
## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
from collections import deque

T = int(input())

def find_start():
    # ì‹œì‘ ì§€ì ì„ ì°¾ëŠ” í•¨ìˆ˜
    for i in range(N):
        for j in range(M):
            if table[i][j] == '@':
                table[i][j] = '.'
                return (i, j)

for testcase in range(T):
    # ì…ë ¥ë°›ê¸°
    M, N = map(int, input().split())
    table = [list(input()) for _ in range(N)]

    # ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì²˜ë¦¬í•  ë¦¬ìŠ¤íŠ¸
    visited = [[False] * M for _ in range(N)]

    # í˜„ì¬ ìƒê·¼ì´ê°€ ìˆì„ ìˆ˜ ìˆëŠ” ì¢Œí‘œë“¤ì„ ë‹´ì€ deque(í)
    now_q = deque()
    # ì‹œì‘ ìœ„ì¹˜ë¥¼ ì €ì¥
    start = find_start()
    # ì‹œì‘ ìœ„ì¹˜ ë°©ë¬¸ ì²˜ë¦¬
    visited[start[0]][start[1]] = True
    # ì‹œì‘ ìœ„ì¹˜ë¥¼ ì‚½ì…í›„ ì‹œì‘
    now_q.append(start)

    # íƒˆì¶œì—¬ë¶€, ë¶ˆê°€ëŠ¥ ì—¬ë¶€ë¥¼ ë³€ìˆ˜ì— ì €ì¥
    escape = False
    impossible = False

    # ìƒí•˜ì¢Œìš° íƒìƒ‰ì„ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]

    # ëª‡ì´ˆê°€ ì§€ë‚¬ëŠ”ì§€ ì €ì¥í•  ë³€ìˆ˜
    count = 0

    # í˜„ì¬ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
    now_fire = []
    # í˜„ì¬ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥
    for i in range(N):
        for j in range(M):
            if table[i][j] == '*':
                now_fire.append((i, j))

    # íƒˆì¶œí–ˆê±°ë‚˜, íƒˆì¶œ ëª»í•˜ëŠ” ê²½ìš° ë°˜ë³µ ì¢…ë£Œ
    while not escape and not impossible:

        next_fire = []
        
        for fire in now_fire:
            for i in range(4):
                nx = fire[0] + dx[i]
                ny = fire[1] + dy[i]

                if 0 <= nx < N and 0 <= ny < M:
                    if table[nx][ny] == '.':
                        table[nx][ny] = '*'
                        next_fire.append((nx, ny))
        
        now_fire = next_fire

        next_queue = deque()

        while now_q:
            now = now_q.popleft()

            for i in range(4):
                nx = now[0] + dx[i]
                ny = now[1] + dy[i]

                if 0 <= nx < N and 0 <= ny < M:
                    if not visited[nx][ny] and table[nx][ny] == '.':
                        next_queue.append((nx, ny))
                        visited[nx][ny] = True
                else:
                    escape = True

        if next_queue == deque():
            impossible = True
        else:
            now_q = next_queue

        count += 1
         
    if escape == True:
        print(count)
    else:
        print('IMPOSSIBLE')
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|237896|856|PyPy3|2440
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. BFS
```

#### **ğŸ˜…ê°œì„ ì **
ì²˜ìŒì— ëª¨ë“  ë¶ˆì— ëŒ€í•´ì„œ ìƒí•˜ì¢Œìš° íƒìƒ‰ì„ ì§„í–‰í•œ í›„, ìƒˆë¡œìš´ ë¶ˆì„ ì˜®ê²¨ì£¼ì—ˆë‹¤. ì´ëŸ° ë°©ì‹ì„ ì‚¬ìš©í•˜ë‹¤ ë³´ë‹ˆ, ëª¨ë“  ë¶ˆì„ íƒìƒ‰í•˜ëŠ” ê²ƒì´ ì˜¤ë˜ ê±¸ë ¸ê³ , ìƒˆë¡­ê²Œ ì˜®ê²¨ì¤€ ë¶ˆ ë§Œì´ ë‹¤ì‹œ ì˜†ìœ¼ë¡œ ë¶ˆì„ ì˜®ê²¨ì¤„ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì–´ ë°©ì‹ì„ ë°”ê¾¸ì–´ í†µê³¼í–ˆë‹¤.

### **ë‹¤ë¥¸ í’€ì´**

```python
import io, os, sys


def main():
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    for _ in range(int(input())):
        cols, rows = map(int, input().split())
        board = [list(input().rstrip()) for _ in range(rows)]
        answer = problem(rows, cols, board)
        if answer == -1:
            print("IMPOSSIBLE")
        else:
            print(answer)


def problem(rows, cols, board):
    VOID, WALL, REACH, FIRE = 46, 35, 64, 42
    DELTAS = ((-1, 0), (1, 0), (0, -1), (0, 1))

    fires = []
    reaches = []
    for i, row in enumerate(board):
        for j, elem in enumerate(row):
            if elem == FIRE:
                fires.append((i, j))
            if elem == REACH:
                reaches.append((i, j))

    time = 0
    while True:
        time += 1

        next_fires = []
        for y, x in fires:
            for dy, dx in DELTAS:
                if 0 <= (ny := y + dy) < rows and 0 <= (nx := x + dx) < cols and board[ny][nx] == VOID:
                    next_fires.append((ny, nx))
                    board[ny][nx] = FIRE
        fires = next_fires

        next_reaches = []
        for y, x in reaches:
            for dy, dx in DELTAS:
                if 0 <= (ny := y + dy) < rows and 0 <= (nx := x + dx) < cols:
                    if board[ny][nx] == VOID:
                        next_reaches.append((ny, nx))
                        board[ny][nx] = REACH
                else:
                    return time
        reaches = next_reaches

        if not reaches:
            return -1


if __name__ == "__main__":
    sys.exit(main())
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
20210805|162292|312|PyPy3|1603
#### **ğŸ“í•´ì„¤**

```python
from collections import deque

T = int(input())

def find_start():
    # ì‹œì‘ ì§€ì ì„ ì°¾ëŠ” í•¨ìˆ˜
    for i in range(N):
        for j in range(M):
            if table[i][j] == '@':
                table[i][j] = '.'
                return (i, j)

for testcase in range(T):
    # ì…ë ¥ë°›ê¸°
    M, N = map(int, input().split())
    table = [list(input()) for _ in range(N)]

    # ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì²˜ë¦¬í•  ë¦¬ìŠ¤íŠ¸
    visited = [[False] * M for _ in range(N)]

    # í˜„ì¬ ìƒê·¼ì´ê°€ ìˆì„ ìˆ˜ ìˆëŠ” ì¢Œí‘œë“¤ì„ ë‹´ì€ deque(í)
    now_q = deque()
    # ì‹œì‘ ìœ„ì¹˜ë¥¼ ì €ì¥
    start = find_start()
    # ì‹œì‘ ìœ„ì¹˜ ë°©ë¬¸ ì²˜ë¦¬
    visited[start[0]][start[1]] = True
    # ì‹œì‘ ìœ„ì¹˜ë¥¼ ì‚½ì…í›„ ì‹œì‘
    now_q.append(start)

    # íƒˆì¶œì—¬ë¶€, ë¶ˆê°€ëŠ¥ ì—¬ë¶€ë¥¼ ë³€ìˆ˜ì— ì €ì¥
    escape = False
    impossible = False

    # ìƒí•˜ì¢Œìš° íƒìƒ‰ì„ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]

    # ëª‡ì´ˆê°€ ì§€ë‚¬ëŠ”ì§€ ì €ì¥í•  ë³€ìˆ˜
    count = 0

    # í˜„ì¬ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
    now_fire = []
    # í˜„ì¬ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥
    for i in range(N):
        for j in range(M):
            if table[i][j] == '*':
                now_fire.append((i, j))

    # íƒˆì¶œí–ˆê±°ë‚˜, íƒˆì¶œ ëª»í•˜ëŠ” ê²½ìš° ë°˜ë³µ ì¢…ë£Œ
    while not escape and not impossible:

        # ì˜®ê²¨ì§„ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
        next_fire = []
        
        # ë¶ˆì„ ëª¨ë‘ ì˜®ê²¨ì£¼ê³ , ë‹¤ìŒ ë¶ˆì˜ ìœ„ì¹˜ë¥¼ ì €ì¥
        for fire in now_fire:
            for i in range(4):
                nx = fire[0] + dx[i]
                ny = fire[1] + dy[i]

                if 0 <= nx < N and 0 <= ny < M:
                    if table[nx][ny] == '.':
                        table[nx][ny] = '*'
                        next_fire.append((nx, ny))
        
        now_fire = next_fire

        # ë‹¤ìŒ ìƒê·¼ì´ê°€ ìˆì„ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ë¥¼ ì €ì¥í•  deque
        next_queue = deque()

        # í˜„ì¬ ìƒê·¼ì´ê°€ ìˆì„ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ë¥¼ BFSë¡œ ìˆœíšŒí•˜ë©´ì„œ ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì‚½ì…
        while now_q:
            now = now_q.popleft()

            for i in range(4):
                nx = now[0] + dx[i]
                ny = now[1] + dy[i]

                # ë§Œì•½ ì¸ë±ìŠ¤ë¥¼ ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤ë©´
                if 0 <= nx < N and 0 <= ny < M:
                    # ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ê³  ë¹ˆê³µê°„ì´ë¼ë©´
                    if not visited[nx][ny] and table[nx][ny] == '.':
                        # ë‹¤ìŒ ìƒê·¼ì´ì˜ ìœ„ì¹˜ íì— ì‚½ì…
                        next_queue.append((nx, ny))
                        # ë°©ë¬¸ì²˜ë¦¬
                        visited[nx][ny] = True
                # ì¸ë±ìŠ¤ë¥¼ ë²—ì–´ë‚¬ë‹¤ë©´ == ìƒê·¼ì´ê°€ íƒˆì¶œí–ˆë‹¤ë©´
                else:
                    # íƒˆì¶œì„ Trueë¡œ ë°”ê¿ˆ
                    escape = True

        # ì´ë™í•  ìˆ˜ ìˆëŠ” ìœ„ì¹˜ê°€ ì—†ë‹¤ë©´ impossibleì„ trueë¡œ ë°”ê¿ˆ
        if next_queue == deque():
            impossible = True
        else:
            # ì´ë™í•  ìˆ˜ ìˆëŠ” ìœ„ì¹˜ê°€ ìˆë‹¤ë©´ ìƒˆë¡­ê²Œ now_që¥¼ ê°±ì‹ 
            now_q = next_queue

        # ì‹œê°„ì„ ë”í•´ì¤Œ
        count += 1
        
    # íƒˆì¶œ ê°€ëŠ¥í•˜ë‹¤ë©´ ì‹œê°„ì¶œë ¥, ì•„ë‹ˆë¼ë©´ IMPOSSIBLE
    if escape == True:
        print(count)
    else:
        print('IMPOSSIBLE')
```

### **ğŸ”–ì •ë¦¬**

1. ë°°ìš´ì 