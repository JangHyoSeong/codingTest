# [22865] ê°€ìž¥ ë¨¼ ê³³

### **ë‚œì´ë„**
ê³¨ë“œ 4
## **ðŸ“ë¬¸ì œ**
$N$ê°œì˜ ë•… ì¤‘ì—ì„œ í•œ ê³³ì— ìžì·¨ë¥¼ í•˜ë ¤ê³  ì§‘ì„ ì•Œì•„ë³´ê³  ìžˆë‹¤. ì„¸ ëª…ì˜ ì¹œêµ¬ 
$A$, 
$B$, 
$C$ê°€ ìžˆëŠ”ë° ì´ ì¹œêµ¬ë“¤ì´ ì‚´ê³  ìžˆëŠ” ì§‘ìœ¼ë¡œë¶€í„° ê°€ìž¥ ë¨¼ ê³³ì— ì§‘ì„ êµ¬í•˜ë ¤ê³  í•œë‹¤.

ì´ë•Œ, ê°€ìž¥ ë¨¼ ê³³ì€ ì„ íƒí•  ì§‘ì—ì„œ ê±°ë¦¬ê°€ ê°€ìž¥ ê°€ê¹Œìš´ ì¹œêµ¬ì˜ ì§‘ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ê°€ ê°€ìž¥ ë¨¼ ê³³ì„ ì˜ë¯¸í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, 
$X$ ìœ„ì¹˜ì— ìžˆëŠ” ì§‘ì—ì„œ ì¹œêµ¬ 
$A$, 
$B$, 
$C$ì˜ ì§‘ê¹Œì§€ì˜ ê±°ë¦¬ê°€ ê°ê° 3, 5, 4ì´ë¼ ê°€ì •í•˜ê³  
$Y$ ìœ„ì¹˜ì— ìžˆëŠ” ì§‘ì—ì„œ ì¹œêµ¬ 
$A$, 
$B$, 
$C$ì˜ ì§‘ê¹Œì§€ì˜ ê±°ë¦¬ê°€ ê°ê° 5, 7, 2ë¼ê³  í•˜ìž.

ì´ë•Œ, ì¹œêµ¬ë“¤ì˜ ì§‘ìœ¼ë¡œë¶€í„° ë•… 
$X$ì™€ ë•… 
$Y$ ì¤‘ ë” ë¨¼ ê³³ì€ ë•… 
$X$ì´ë‹¤. ì™œëƒí•˜ë©´ 
$X$ì—ì„œ ê°€ìž¥ ê°€ê¹Œìš´ ì¹œêµ¬ì˜ ì§‘ê¹Œì§€ì˜ ê±°ë¦¬ëŠ” 3ì´ê³ , 
$Y$ì—ì„œëŠ” 
$2$ì´ê¸° ë•Œë¬¸ì´ë‹¤.

ì¹œêµ¬ë“¤ì´ ì‚´ê³  ìžˆëŠ” ì§‘ìœ¼ë¡œë¶€í„° ê°€ìž¥ ë¨¼ ê³³ì„ êµ¬í•´ë³´ìž.
### **ìž…ë ¥**
ì²«ë²ˆì§¸ ì¤„ì— ìžì·¨í•  ë•… í›„ë³´ì˜ ê°œìˆ˜ 
$N$ì´ ì£¼ì–´ì§„ë‹¤.

2ë²ˆì§¸ ì¤„ì—ëŠ” ì¹œêµ¬ 
$A$, 
$B$, 
$C$ê°€ ì‚¬ëŠ” ìœ„ì¹˜ê°€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì£¼ì–´ì§„ë‹¤. ì´ë•Œ ì¹œêµ¬ë“¤ì€ 
$N$ê°œì˜ ë•… ì¤‘ í•˜ë‚˜ì— ì‚¬ëŠ” ê²ƒì´ ë³´ìž¥ëœë‹¤. (ê°™ì€ ìœ„ì¹˜ì—ì„œ ì‚´ ìˆ˜ ìžˆë‹¤.)

3ë²ˆì§¸ ì¤„ì—ëŠ” ë•…ê³¼ ë•… ì‚¬ì´ë¥¼ ìž‡ëŠ” ë„ë¡œì˜ ê°œìˆ˜ 
$M$ì´ ì£¼ì–´ì§„ë‹¤.

ê·¸ ë‹¤ìŒì¤„ë¶€í„° 
$M + 3$ë²ˆì§¸ ì¤„ê¹Œì§€ ë•… 
$D$, ë•… 
$E$, ë•… 
$D$ì™€ ë•… 
$E$ì™€ ì‚¬ì´ë¥¼ ì—°ê²°í•˜ëŠ” ë„ë¡œì˜ ê¸¸ì´ 
$L$ì´ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì£¼ì–´ì§„ë‹¤. ì´ ë„ë¡œëŠ” ì–‘ë±¡í•­ í†µí–‰ì´ ê°€ëŠ¥í•˜ë‹¤.
### **ì¶œë ¥**
ì¹œêµ¬ë“¤ì´ ì‚´ê³  ìžˆëŠ” ì§‘ìœ¼ë¡œë¶€í„° ê°€ìž¥ ë¨¼ ê³³ì˜ ë•… ë²ˆí˜¸ë¥¼ ì¶œë ¥í•œë‹¤. ë§Œì•½ ê°€ìž¥ ë¨¼ ê³³ì´ ì—¬ëŸ¬ ê³³ì´ë¼ë©´ ë²ˆí˜¸ê°€ ê°€ìž¥ ìž‘ì€ ë•…ì˜ ë²ˆí˜¸ë¥¼ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œìž…ì¶œë ¥**

**ì˜ˆì œ ìž…ë ¥1**

```
6
1 2 5
8
1 2 1
2 3 4
1 4 2
2 5 3
1 6 5
5 6 2
3 4 2
4 5 6
```

**ì˜ˆì œ ì¶œë ¥1**

```
3
```

### **ì¶œì²˜**

## **ðŸ§CODE REVIEW**

### **ðŸ§¾ë‚˜ì˜ í’€ì´**

```python
import sys
from heapq import heappush, heappop

INF = int(21e8)

N = int(sys.stdin.readline().rstrip())
A, B, C = map(int, sys.stdin.readline().rstrip().split())
M = int(sys.stdin.readline().rstrip())

edges = [[] for _ in range(N+1)]
for _ in range(M):
    D, E, length = map(int, sys.stdin.readline().rstrip().split())
    edges[D].append((length, E))
    edges[E].append((length, D))

def dijkstra(start):
    dist = [INF] * (N+1)
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        now_dist, node = heappop(pq)
        if now_dist > dist[node]:
            continue

        for next_dist, next_node in edges[node]:
            new_dist = now_dist + next_dist
            if new_dist < dist[next_node]:
                dist[next_node] = new_dist
                heappush(pq, (new_dist, next_node))
    
    return dist

dist_A = dijkstra(A)
dist_B = dijkstra(B)
dist_C = dijkstra(C)

answer = -1
max_min_dist = -1

for i in range(1, N+1):
    min_dist = min(dist_A[i], dist_B[i], dist_C[i])
    if min_dist > max_min_dist:
        max_min_dist = min_dist
        answer = i

    elif min_dist == max_min_dist and i < answer:
        answer = i

print(answer)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|203632|2280|PyPy3|1175
#### **ðŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë‹¤ìµìŠ¤íŠ¸ë¼
```

#### **ðŸ“í•´ì„¤**

```python
import sys
from heapq import heappush, heappop

INF = int(21e8)

# ìž…ë ¥ë°›ê¸°
N = int(sys.stdin.readline().rstrip())
A, B, C = map(int, sys.stdin.readline().rstrip().split())
M = int(sys.stdin.readline().rstrip())

edges = [[] for _ in range(N+1)]
for _ in range(M):
    D, E, length = map(int, sys.stdin.readline().rstrip().split())
    edges[D].append((length, E))
    edges[E].append((length, D))

# ì‹œìž‘ì§€ì ì„ ìž…ë ¥ë°›ê³ , ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ë¦¬í„´
def dijkstra(start):
    dist = [INF] * (N+1)
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        now_dist, node = heappop(pq)
        if now_dist > dist[node]:
            continue

        for next_dist, next_node in edges[node]:
            new_dist = now_dist + next_dist
            if new_dist < dist[next_node]:
                dist[next_node] = new_dist
                heappush(pq, (new_dist, next_node))
    
    return dist

# ê°ê° A, B, Cì—ì„œ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•¨
dist_A = dijkstra(A)
dist_B = dijkstra(B)
dist_C = dijkstra(C)

# ê°€ìž¥ ë¨¼ ë…¸ë“œ
answer = -1

# ê·¸ ë•Œì˜ ê±°ë¦¬
max_min_dist = -1

# ëª¨ë“  ë…¸ë“œë¥¼ í™•ì¸í•˜ë©´ì„œ
for i in range(1, N+1):

    # í˜„ìž¬ ë…¸ë“œì—ì„œ A, B, Cê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•¨
    min_dist = min(dist_A[i], dist_B[i], dist_C[i])

    # ì´ ë•Œ ìµœë‹¨ê±°ë¦¬ê°€ ë” ë©€ë‹¤ë©´ ê°±ì‹ 
    if min_dist > max_min_dist:
        max_min_dist = min_dist
        answer = i

    # ë²ˆí˜¸ ê°±ì‹ 
    elif min_dist == max_min_dist and i < answer:
        answer = i

print(answer)
```