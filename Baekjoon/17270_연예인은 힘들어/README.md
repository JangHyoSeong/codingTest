# [17270] ì—°ì˜ˆì¸ì€ í˜ë“¤ì–´

### **ë‚œì´ë„**
ê³¨ë“œ 3
## **ğŸ“ë¬¸ì œ**
ì—°ì˜ˆì¸ ê¹€ì˜ê´‘ì„ ë„ˆë¬´ ë‹®ì•„ì„œ ê¸¸ê±°ë¦¬ì—ì„œ ë§¤ë²ˆ ì‚¬ì§„ì´ ì°íˆëŠ” ì§€í—Œì´ëŠ” ì‚¬ëŒë“¤ì—ê²Œ ë…¸ì¶œë˜ëŠ” ê²ƒì„ ë§¤ìš° êº¼ë ¤í•œë‹¤. í•˜ì§€ë§Œ ì¹œêµ¬ì¸ ì„±í•˜ì™€ ì•½ì†ì„ í•˜ë©´ ì„±í•˜ëŠ” ë§¤ë²ˆ ëŠ¦ê¸° ë•Œë¬¸ì— ê¸¸ê±°ë¦¬ì— ë‚˜ì˜¨ ì§€í—Œì´ëŠ” ë§¤ë²ˆ ì„±í•˜ë¥¼ ê¸°ë‹¤ë¦°ë‹¤. ì•½ì† ì¥ì†Œì—ì„œ ì„±í•˜ì—ê²Œ ì „í™”ë¥¼ í•˜ë©´ ë§¤ë²ˆ â€œê°€ëŠ” ì¤‘â€ ì´ë¼ëŠ” ëŒ€ë‹µë§Œ ë“£ê³  ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ê¸¸ê±°ë¦¬ì—ì„œ ì‚¬ëŒë“¤ì—ê²Œ ì‚¬ì§„ì„ ì°íˆëŠ” ì§€í—Œì´ëŠ” ìŠ¤íŠ¸ë ˆìŠ¤ë¥¼ ì‹¬í•˜ê²Œ ë°›ê³  ìˆë‹¤. ì°¸ì§€ ëª»í•œ ì§€í—Œì´ëŠ” ì„±í•˜ì˜ í•¸ë“œí°ì„ í•´í‚¹í•˜ì—¬ì„œ í•­ìƒ ì–´ë”” ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.

ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ì‹¬í•´ì§„ ì§€í—Œì´ëŠ” ì„±í•˜ì™€ì˜ ì•½ì† ì¥ì†Œë¥¼ ë°”ê¾¸ë ¤ê³  í•œë‹¤. ê·¸ ìœ„ì¹˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤. ì¥ì†Œì˜ ë²ˆí˜¸ëŠ” 1ë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ë¶™ì–´ ìˆë‹¤.

1. ì§€í—Œì´ì˜ ì¶œë°œ ìœ„ì¹˜ì™€ ì„±í•˜ì˜ ì¶œë°œ ìœ„ì¹˜ëŠ” ìƒˆë¡œìš´ ì•½ì† ì¥ì†Œê°€ ë  ìˆ˜ ì—†ë‹¤.
2. ì„±í’ˆë„ í›Œë¥­í•œ ì§€í—Œì´ëŠ” ìƒˆë¡œìš´ ì•½ì† ì¥ì†ŒëŠ” ì§€í—Œì´ê°€ ê±¸ë¦¬ëŠ” ìµœë‹¨ ì‹œê°„ê³¼ ì„±í•˜ê°€ ê±¸ë¦¬ëŠ” ìµœë‹¨ ì‹œê°„ì˜ í•©ì´ ìµœì†Œê°€ ë˜ë„ë¡ í•˜ê³  ì‹¶ë‹¤.
3. ì§€í—Œì´ê°€ ë” ëŠ¦ê²Œ ë„ì°©í•˜ë©´ ì„±í•˜ì—ê²Œ ì•ˆì¢‹ì€ ì†Œë¦¬ë¥¼ ë“¤ì„ ê²ƒì´ ë»”í•˜ê¸°ì—, 1ë²ˆê³¼ 2ë²ˆ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¥ì†Œ ì¤‘ì—ì„œë„ ì§€í—Œì´ê°€ ì„±í•˜ë³´ë‹¤ ëŠ¦ê²Œ ë„ì°©í•˜ëŠ” ê³³ì€ ì•½ì† ì¥ì†Œê°€ ë  ìˆ˜ ì—†ë‹¤.
4. ìœ„ì˜ ì„¸ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•˜ëŠ” ì•½ì† ì¥ì†Œê°€ ì—¬ëŸ¬ ê³³ì´ ìˆë‹¤ë©´, ê·¸ ì¤‘ì— ì§€í—Œì´ë¡œë¶€í„° ê°€ì¥ ê°€ê¹Œìš´ ê³³ì´ ìµœì¢… ì•½ì† ì¥ì†Œê°€ ëœë‹¤. ê·¸ëŸ° ì¥ì†Œë„ ì—¬ëŸ¬ ê³³ì´ ìˆë‹¤ë©´, ê·¸ ì¤‘ì— ë²ˆí˜¸ê°€ ê°€ì¥ ì‘ì€ ì¥ì†Œê°€ ìµœì¢… ì•½ì† ì¥ì†Œê°€ ëœë‹¤.

![ì´ë¯¸ì§€](https://upload.acmicpc.net/fe6c7237-d6f3-417c-9eeb-a368228bc999/-/preview/)

ìœ„ì™€ ê°™ì€ ìƒí™©ì´ ìˆë‹¤ê³  í–ˆì„ ë•Œ ìƒˆë¡œ ë°”ê¿€ ì•½ì† ì¥ì†Œë¥¼ ì°¾ì•„ë³´ì.

- (ì¡°ê±´ 1) 3ë²ˆê³¼ 6ë²ˆì€ ì§€í—Œì´ì™€ ì„±í•˜ì˜ ì¶œë°œì§€ì´ê¸° ë•Œë¬¸ì— ìƒˆë¡œìš´ ì•½ì† ì¥ì†Œ í›„ë³´ì—ì„œ ì œì™¸ëœë‹¤.
- (ì¡°ê±´ 2) ìœ„ ìƒí™©ì—ì„œ ì„±í•˜ì™€ ì§€í—Œì˜ ìµœë‹¨ ê±°ë¦¬ì˜ í•©ì˜ ìµœì†ŒëŠ” 6ë¶„ì´ë‹¤. ì´ ë•Œ, ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì•½ì† ì¥ì†ŒëŠ” 1ë²ˆ, 2ë²ˆ, 5ë²ˆ, 7ë²ˆì´ë‹¤.
- (ì¡°ê±´ 3) 5ë²ˆì€ ì„±í•˜ê°€ ë¨¼ì € ë„ì°©í•˜ì—¬ì„œ ê¸°ë‹¬ë¦¬ê³  ìˆê¸° ë•Œë¬¸ì— ì§€í—Œì´ëŠ” ê¾¸ì¤‘ì„ ë“¤ì„ ìœ„í—˜ì´ ìˆë‹¤. ê·¸ë˜ì„œ 5ë²ˆì€ ì•½ì† ì¥ì†Œ í›„ë³´ì—ì„œ ì œì™¸ëœë‹¤.
- (ì¡°ê±´ 4) 2ë²ˆ ìœ„ì¹˜ëŠ” ì„±í•˜ì™€ ì§€í—Œì´ê°€ ë™ì‹œì— ë„ì°©, 7ë²ˆì€ ì§€í—Œì´ëŠ” 2ë¶„ ê±¸ë ¤ì„œ ë„ì°©í•˜ê³  ì„±í•˜ëŠ” 4ë¶„ ê±¸ë ¤ì„œ ë„ì°©í•œë‹¤. 1ë²ˆì€ ì§€í—Œì´ëŠ” 1ë¶„, ì„±í•˜ëŠ” 5ë¶„ ê±¸ë ¤ì„œ ë„ì°©í•œë‹¤. ë”°ë¼ì„œ, ì§€í—Œì´ê°€ ì›í•˜ëŠ” ì´ìƒì ì¸ ì•½ì† ì¥ì†ŒëŠ” 1ë²ˆì´ ëœë‹¤.

ì—°ì˜ˆì¸ì„ ë‹®ì•„ì„œ ê³ í†µë°›ëŠ” ì§€í—Œì´ë¥¼ ìœ„í•´ ìƒˆë¡œìš´ ì•½ì†ì¥ì†Œë¥¼ ì°¾ì•„ì£¼ì.
### **ì…ë ¥**
ì²« ë²ˆì§¸ ì¤„ì—ëŠ” ì•½ì† ì¥ì†Œ í›„ë³´ì˜ ìˆ˜ Vì™€ ì•½ì† ì¥ì†Œë¥¼ ì—°ê²°í•˜ëŠ” ì´ ê¸¸ì˜ ìˆ˜ Mì´ ì£¼ì–´ì§„ë‹¤. (2 â‰¤ V â‰¤ 100, 1 â‰¤ M â‰¤ 1,000)

ê·¸ë¦¬ê³  ë‹¤ìŒ Mê°œì˜ ê° ì¤„ì—ëŠ” a, b, c ê°€ ì£¼ì–´ì§„ë‹¤. a, bëŠ” ê¸¸ì˜ ì‹œì‘ê³¼ ëì´ë©° cëŠ” ê·¸ ê¸¸ì„ ì§€ë‚˜ê°€ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ë‚˜íƒ€ë‚¸ë‹¤.

(1 â‰¤ a, b â‰¤ V, cëŠ” 10,000ì´í•˜ì˜ ìì—°ìˆ˜, ê¸¸ì€ ì–‘ë°©í–¥ì´ë‹¤)

ê·¸ë¦¬ê³  ê·¸ ë‹¤ìŒ ì¤„ì—ëŠ” ì§€í—Œì´ì˜ ìœ„ì¹˜ J ì™€ ì„±í•˜ì˜ ìœ„ì¹˜ S ê°€ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ J, S â‰¤ V)

ì§€í˜„ì´ì™€ ì„±í•˜ê°€ í•­ìƒ ë§Œë‚  ìˆ˜ ìˆëŠ” ì…ë ¥ë§Œ ì£¼ì–´ì§„ë‹¤.
### **ì¶œë ¥**
ì—°ì˜ˆì¸ì„ ë‹®ì•„ì„œ ê³ í†µë°›ëŠ” ì§€í—Œì´ë¥¼ ìœ„í•œ ì´ìƒì ì¸ ì•½ì† ì¥ì†Œì˜ ìœ„ì¹˜ë¥¼ ì¶œë ¥í•œë‹¤. ë§Œì•½ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì•½ì† ì¥ì†Œê°€ ì—†ë‹¤ë©´ -1ì„ ì¶œë ¥í•˜ë¼.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
8 10
1 2 2
2 6 3
2 7 2
1 3 1
3 7 2
4 7 5
5 6 2
5 7 2
7 8 2
5 8 2
3 6
```

**ì˜ˆì œ ì¶œë ¥1**

```
1
```

**ì˜ˆì œ ì…ë ¥2**

```
5 6
1 2 3
1 5 1
2 5 3
2 3 4
3 4 2
4 5 1
2 4
```

**ì˜ˆì œ ì¶œë ¥2**

```
-1
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
from heapq import heappush, heappop

INF = int(21e8)

V, M = map(int, input().split())

edges = [[] for _ in range(V+1)]
for _ in range(M):
    a, b, c = map(int, input().split())
    edges[a].append((c, b))
    edges[b].append((c, a))
J, S = map(int, input().split())

def find_min_dist(start_node):
    dist = [INF] * (V+1)
    dist[start_node] = 0

    pq = [(0, start_node)]
    while pq:
        now_dist, now_node = heappop(pq)

        if now_dist > dist[now_node]:
            continue

        for next_dist, next_node in edges[now_node]:
            new_dist = dist[now_node] + next_dist

            if new_dist < dist[next_node]:
                heappush(pq, (new_dist, next_node))
                dist[next_node] = new_dist
    
    return dist

J_dist = find_min_dist(J)
S_dist = find_min_dist(S)

min_dist = INF
min_dist_nodes = []

for v in range(1, V+1):

    if v not in [J, S]:
        now_dist_sum = J_dist[v] + S_dist[v]

        if min_dist > now_dist_sum:
            min_dist = now_dist_sum
            min_dist_nodes = [v]
        
        elif min_dist == now_dist_sum:
            min_dist_nodes.append(v)

min_J_dist = INF
answer_node = 0

for node in min_dist_nodes:
    if J_dist[node] > S_dist[node]:
        continue

    if min_J_dist > J_dist[node]:
        min_J_dist = J_dist[node]
        answer_node = node

print(answer_node if answer_node else -1)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|35508|64|Python3|1387
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë‹¤ìµìŠ¤íŠ¸ë¼
```

### **ë‹¤ë¥¸ í’€ì´**

```python
import sys, heapq
input = sys.stdin.readline

def dijkstra(G, start):
    hq = [(0, start)]
    dp = [1e9] * len(G)
    dp[start] = 0
    while hq:
        cw, cn = heapq.heappop(hq)
        if dp[cn] < cw:
            continue
        for nn, nw in G[cn]:
            w = cw + nw
            if w < dp[nn]:
                dp[nn] = w
                heapq.heappush(hq, (w, nn))
    return dp

def solve():
    V, M = map(int, input().split())
    G = [[] for _ in range(V + 1)]
    for _ in range(M):
        a, b, c = map(int, input().split())
        G[a].append((b, c))
        G[b].append((a, c))
    J, S = map(int, input().split())
    jtime = dijkstra(G, J)
    stime = dijkstra(G, S)
    candi = []
    dist = 2e9
    for i in range(1, V + 1):
        if i == J or i == S:
            continue
        hap = jtime[i] + stime[i]
        if hap < dist:
            dist = hap
            candi = [i]
        elif hap == dist:
            candi.append(i)
    ans = -1
    for c in candi:
        if jtime[c] > stime[c]:
            continue
        if ans == -1 or jtime[c] < jtime[ans]:
            ans = c
    print(ans)

solve()
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
tkqmfp26|33212|40|Python3|1137
#### **ğŸ“í•´ì„¤**

```python
from heapq import heappush, heappop

# ì„ì˜ì˜ í° ê°’
INF = int(21e8)

# ì…ë ¥ë°›ê¸°
V, M = map(int, input().split())

edges = [[] for _ in range(V+1)]

# ê°„ì„ ì •ë³´ ì €ì¥
for _ in range(M):
    a, b, c = map(int, input().split())
    edges[a].append((c, b))
    edges[b].append((c, a))
J, S = map(int, input().split())

# ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•¨
def find_min_dist(start_node):
    dist = [INF] * (V+1)
    dist[start_node] = 0

    pq = [(0, start_node)]
    while pq:
        now_dist, now_node = heappop(pq)

        if now_dist > dist[now_node]:
            continue

        for next_dist, next_node in edges[now_node]:
            new_dist = dist[now_node] + next_dist

            if new_dist < dist[next_node]:
                heappush(pq, (new_dist, next_node))
                dist[next_node] = new_dist
    
    # ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¦¬í„´
    return dist

# ê°ê° J, Sì—ì„œ ì‹œì‘í•´ì„œ ìµœë‹¨ê±°ë¦¬ë¥¼ í™•ì¸
J_dist = find_min_dist(J)
S_dist = find_min_dist(S)

# ìµœë‹¨ ê±°ë¦¬ í•©ì˜ ìµœì†Œê°€ ë  ê°’
min_dist = INF

# ìµœì†Œì¸ ê°’ì´ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°, ë…¸ë“œë“¤ì„ ì „ë¶€ ì €ì¥
min_dist_nodes = []

# ëª¨ë“  ë…¸ë“œë¥¼ í™•ì¸í•˜ë©´ì„œ
for v in range(1, V+1):

    # ì‹œì‘ ì§€ì ì„ ì œì™¸í•˜ê³ 
    if v not in [J, S]:
        now_dist_sum = J_dist[v] + S_dist[v]

        # ìµœë‹¨ ê±°ë¦¬ ê°±ì‹ ì´ ê°€ëŠ¥í•˜ë‹¤ë©´ ê°±ì‹ 
        if min_dist > now_dist_sum:
            min_dist = now_dist_sum
            min_dist_nodes = [v]
        
        # ê±°ë¦¬ê°€ ê°™ë‹¤ë©´ ë…¸ë“œ í›„ë³´ë¡œ ì €ì¥
        elif min_dist == now_dist_sum:
            min_dist_nodes.append(v)

# Jê°€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì°¾ê¸° ìœ„í•´ í™•ì¸
min_J_dist = INF
answer_node = 0

# í›„ë³´ ë…¸ë“œë“¤ì„ í™•ì¸í•˜ë©´ì„œ
for node in min_dist_nodes:

    # Jê°€ Së³´ë‹¤ ë” ë§ì´ ì´ë™í•˜ëŠ” ê²½ìš°ëŠ” ì œì™¸
    if J_dist[node] > S_dist[node]:
        continue

    # Jì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ í™•ì¸í•˜ë©´ì„œ ê°±ì‹ 
    if min_J_dist > J_dist[node]:
        min_J_dist = J_dist[node]
        answer_node = node

# ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë…¸ë“œê°€ ì—†ë‹¤ë©´ -1 ì¶œë ¥, ì•„ë‹ˆë¼ë©´ ì •ë‹µ ì¶œë ¥
print(answer_node if answer_node else -1)
```