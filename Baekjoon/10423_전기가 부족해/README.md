# [10423] ì „ê¸°ê°€ ë¶€ì¡±í•´

### **ë‚œì´ë„**
ê³¨ë“œ 3
## **ðŸ“ë¬¸ì œ**
ì„¸ê³„ì—ì„œ GDPê°€ ê°€ìž¥ ë†’ì€ ì„œê°• ë‚˜ë¼ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ì™€ í•˜ë“œì›¨ì–´ ê¸°ìˆ ì´ ëª¨ë‘ ìµœê³ ë¼ì„œ ITê°•êµ­ì´ë¼ ë¶ˆë¦¬ê³ , 2015ë…„ë¶€í„° ì„¸ìƒì—ì„œ ê°€ìž¥ ì‚´ê¸° ì¢‹ì€ ë‚˜ë¼ 1ë“±ìœ¼ë¡œ ê¼½ížˆê³  ìžˆë‹¤. 

ì‚´ê¸° ì¢‹ì€ ë‚˜ë¼ 1ë“±ìœ¼ë¡œ ê¼½ížŒ ì´í›„ ì™¸êµ­ì¸ ë°©ë¬¸ê°ë“¤ì´ ë§Žì•„ì¡Œê³ , ê·¸ì— ë”°ë¼ ì „ê¸° ì†Œë¹„ìœ¨ì´ ì¦ê°€í•˜ì—¬ ì „ê¸°ê°€ ë§Žì´ ë¶€ì¡±í•œ ìƒí™©ì´ ë˜ì—ˆë‹¤. ë”°ë¼ì„œ ì„œê°• ë‚˜ë¼ì˜ ëŒ€í†µë ¹ì€ ìµœê·¼ ê°œë°œì´ ì™„ë£Œëœ YNYë°œì „ì†Œ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰ í•˜ê¸°ë¡œ í•˜ì˜€ë‹¤. ë°œì „ì†Œë¥¼ ë§Œë“¤ ë•Œ ì¤‘ìš”í•œ ê²ƒì€ ë°œì „ì†Œ ê±´ë¬¼ê³¼ ë„ì‹œë¡œ ì „ê¸°ë¥¼ ê³µê¸‰í•´ ì¤„ ì¼€ì´ë¸”ì´ë‹¤. ë°œì „ì†ŒëŠ” ì´ë¯¸ íŠ¹ì • ë„ì‹œì— ê±´ì„¤ë˜ì–´ ìžˆê³ , ë”°ë¼ì„œ ì¶”ê°€ì ìœ¼ë¡œ ë“œëŠ” ë¹„ìš©ì€ ì¼€ì´ë¸”ì„ ì„¤ì¹˜í•  ë•Œ ë“œëŠ” ë¹„ìš©ì´ ì „ë¶€ì´ë‹¤. ì´ í”„ë¡œì íŠ¸ì˜ ë¬¸ì œëŠ” ì¼€ì´ë¸”ì„ ì„¤ì¹˜í•  ë•Œ ë“œëŠ” ë¹„ìš©ì´ êµ‰ìž¥ížˆ í¬ë¯€ë¡œ ì´ë¥¼ ìµœì†Œí™”í•´ì„œ ì„¤ì¹˜í•˜ì—¬ ëª¨ë“  ë„ì‹œì— ì „ê¸°ë¥¼ ê³µê¸‰í•˜ëŠ” ê²ƒì´ë‹¤. ì—¬ëŸ¬ë¶„ì€ Nê°œì˜ ë„ì‹œê°€ ìžˆê³  Mê°œì˜ ë‘ ë„ì‹œë¥¼ ì—°ê²°í•˜ëŠ” ì¼€ì´ë¸”ì˜ ì •ë³´ì™€ Kê°œì˜ YNYë°œì „ì†Œê°€ ì„¤ì¹˜ëœ ë„ì‹œê°€ ì£¼ì–´ì§€ë©´ ì¼€ì´ë¸” ì„¤ì¹˜ ë¹„ìš©ì„ ìµœì†Œë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ë„ì‹œì— ì „ê¸°ê°€ ê³µê¸‰í•  ìˆ˜ ìžˆë„ë¡ í•´ê²°í•´ì•¼ í•œë‹¤. ì¤‘ìš”í•œ ì ì€ ì–´ëŠ í•œ ë„ì‹œê°€ ë‘ ê°œì˜ ë°œì „ì†Œì—ì„œ ì „ê¸°ë¥¼ ê³µê¸‰ë°›ìœ¼ë©´ ë‚­ë¹„ê°€ ë˜ë¯€ë¡œ ì¼€ì´ë¸”ì´ ì—°ê²°ë˜ì–´ìžˆëŠ” ë„ì‹œì—ëŠ” ë°œì „ì†Œê°€ ë°˜ë“œì‹œ í•˜ë‚˜ë§Œ ì¡´ìž¬í•´ì•¼ í•œë‹¤. ì•„ëž˜ Figure 1ë¥¼ ë³´ìž. 9ê°œì˜ ë„ì‹œì™€ 3 ê°œì˜ YNYë°œì „ì†Œ(A,B,I)ê°€ ìžˆê³ , ê°ê°ì˜ ë„ì‹œë“¤ì„ ì—°ê²°í•  ë•Œ ë“œëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§„ë‹¤.


![img](https://www.acmicpc.net/upload/images2/E1.png)
Figure 1


![img](https://www.acmicpc.net/upload/images2/E2.png)
Figure 2

ì´ ì˜ˆì œì—ì„œ ëª¨ë“  ë„ì‹œì— ì „ê¸°ë¥¼ ê³µê¸‰í•˜ê¸° ìœ„í•˜ì—¬ ì„¤ì¹˜í•  ì¼€ì´ë¸”ì˜ ìµœì†Œ ë¹„ìš©ì€ 22ì´ê³ , Figure 2ì˜ êµµì€ ê°„ì„ ì´ ì—°ê²°í•œ ì¼€ì´ë¸”ì´ë‹¤. B ë„ì‹œëŠ” ì—°ê²°ëœ ë„ì‹œê°€ í•˜ë‚˜ë„ ì—†ì§€ë§Œ, ë°œì „ì†Œê°€ ì„¤ì¹˜ëœ ë„ì‹œëŠ” ì „ê¸°ê°€ ê³µê¸‰ë  ìˆ˜ ìžˆê¸° ë•Œë¬¸ì— ìƒê´€ì—†ë‹¤.
### **ìž…ë ¥**
ì²«ì§¸ ì¤„ì—ëŠ” ë„ì‹œì˜ ê°œìˆ˜ N(1 â‰¤ N â‰¤ 1,000)ê³¼ ì„¤ì¹˜ ê°€ëŠ¥í•œ ì¼€ì´ë¸”ì˜ ìˆ˜ M(1 â‰¤ M â‰¤ 100,000)ê°œ, ë°œì „ì†Œì˜ ê°œìˆ˜ K(1 â‰¤ K â‰¤ N)ê°œê°€ ì£¼ì–´ì§„ë‹¤. ë‘˜ì§¸ ì¤„ì—ëŠ” ë°œì „ì†Œê°€ ì„¤ì¹˜ëœ ë„ì‹œì˜ ë²ˆí˜¸ê°€ ì£¼ì–´ì§„ë‹¤. ì…‹ì§¸ ì¤„ë¶€í„° Mê°œì˜ ë‘ ë„ì‹œë¥¼ ì—°ê²°í•˜ëŠ” ì¼€ì´ë¸”ì˜ ì •ë³´ê°€ u, v, wë¡œ ì£¼ì–´ì§„ë‹¤. ì´ëŠ” uë„ì‹œì™€ vë„ì‹œë¥¼ ì—°ê²°í•˜ëŠ” ì¼€ì´ë¸”ì„ ì„¤ì¹˜í•  ë•Œ wì˜ ë¹„ìš©ì´ ë“œëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. wëŠ” 10,000ë³´ë‹¤ ìž‘ê±°ë‚˜ ê°™ì€ ì–‘ì˜ ì •ìˆ˜ì´ë‹¤.
### **ì¶œë ¥**
ëª¨ë“  ë„ì‹œì— ì „ê¸°ë¥¼ ê³µê¸‰í•  ìˆ˜ ìžˆë„ë¡ ì¼€ì´ë¸”ì„ ì„¤ì¹˜í•˜ëŠ” ë° ë“œëŠ” ìµœì†Œë¹„ìš©ì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œìž…ì¶œë ¥**

**ì˜ˆì œ ìž…ë ¥1**

```
9 14 3
1 2 9
1 3 3
1 4 8
2 4 10
3 4 11
3 5 6
4 5 4
4 6 10
5 6 5
5 7 4
6 7 7
6 8 4
7 8 5
7 9 2
8 9 5
```

**ì˜ˆì œ ì¶œë ¥1**

```
22
```

**ì˜ˆì œ ìž…ë ¥2**

```
4 5 1
1
1 2 5
1 3 5
1 4 5
2 3 10
3 4 10
```

**ì˜ˆì œ ì¶œë ¥2**

```
15
```

**ì˜ˆì œ ìž…ë ¥3**

```
10 9 5
1 4 6 9 10
1 2 3
2 3 8
3 4 5
4 5 1
5 6 2
6 7 6
7 8 3
8 9 4
9 10 1
```

**ì˜ˆì œ ì¶œë ¥3**

```
16
```

### **ì¶œì²˜**

## **ðŸ§CODE REVIEW**

### **ðŸ§¾ë‚˜ì˜ í’€ì´**

```python
import sys

def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, rank, x, y):
    root_x = find(parent, x)
    root_y = find(parent, y)

    if root_x != root_y:
        if rank[root_x] > rank[root_y]:
            parent[root_y] = root_x

        elif rank[root_x] < rank[root_y]:
            parent[root_x] = root_y

        else:
            parent[root_y] = root_x
            rank[root_x] += 1


N, M, K = map(int, sys.stdin.readline().rstrip().split())
generators = list(map(int, sys.stdin.readline().rstrip().split()))

edges = [list(map(int, input().split())) for _ in range(M)]
edges.sort(key=lambda x : x[2])

parent = list(range(N+1))
rank = [0] * (N+1)

virtual_node = 0
for generator in generators:
    union(parent, rank, virtual_node, generator)

min_cost = 0
for u, v, w in edges:
    if find(parent, u) != find(parent, v):
        union(parent, rank, u, v)
        min_cost += w

print(min_cost)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|122072|292|PyPy3|986
#### **ðŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. MST
2. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜
```

### **ë‹¤ë¥¸ í’€ì´**

```python
# MST - 10423ë²ˆ - ì „ê¸°ê°€ ë¶€ì¡±í•´
import sys
from heapq import *

input = sys.stdin.readline
sys.setrecursionlimit(10 ** 6)

v, e, e_num = map(int, input().split())
electric = list(map(int, input().split()))
edges = []
q = []
for i in range(e):
    s, e, c = map(int, input().split())
    heappush(q, (c, s, e))

## ë°œì „ì†Œë¼ë©´ parentê°€ 0ì´ë‹¤ -> ë°œì „ì†Œë¥¼ í•­ìƒ parentë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œ!!!
cycle = [i for i in range(v+1)]
for i in electric:
    cycle[i] = 0
# print(cycle)


## ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ
def get_parent(v):
    if cycle[v] != v:
        cycle[v] = get_parent(cycle[v])
    return cycle[v]


def union_parent(v1, v2):
    v1_parent = get_parent(v1)
    v2_parent = get_parent(v2)
    if v1_parent != v2_parent:
        if v1_parent > v2_parent:
            cycle[v1_parent] = v2_parent
        else:
            cycle[v2_parent] = v1_parent
        return True
    return False


edge_cnt = 0
ans = 0
while q:
    c, s, e = heappop(q)
    if union_parent(s, e):
        ans += c
        edge_cnt += 1
    if edge_cnt == v-e_num:
        break
print(ans)

```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
leedrkr323|48308|164|Python3|1084
#### **ðŸ“í•´ì„¤**

```python
import sys

def find(parent, x):
    # ìœ ë‹ˆì˜¨ íŒŒì¸ë“œë¥¼ ìœ„í•œ í•¨ìˆ˜ ì„ ì–¸
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, rank, x, y):
    root_x = find(parent, x)
    root_y = find(parent, y)

    if root_x != root_y:
        if rank[root_x] > rank[root_y]:
            parent[root_y] = root_x

        elif rank[root_x] < rank[root_y]:
            parent[root_x] = root_y

        else:
            parent[root_y] = root_x
            rank[root_x] += 1

# ìž…ë ¥ë°›ìŒ
N, M, K = map(int, sys.stdin.readline().rstrip().split())
generators = list(map(int, sys.stdin.readline().rstrip().split()))

# í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ìœ„í•´ ê°„ì„ ì„ ê°€ì¤‘ì¹˜ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
edges = [list(map(int, input().split())) for _ in range(M)]
edges.sort(key=lambda x : x[2])

# ìœ ë‹ˆì˜¨íŒŒì¸ë“œë¥¼ ìœ„í•œ ë¦¬ìŠ¤íŠ¸ ì„ ì–¸
parent = list(range(N+1))
rank = [0] * (N+1)

# ëª¨ë“  ë°œì „ì†Œë¥¼ ê°€ìƒì˜ ë…¸ë“œë¡œ ë¬¶ì–´ì„œ ê°„ì£¼í•¨
# ì´ëŸ¬ë©´, ëª¨ë“  ë°œì „ì†Œë¥¼ í•˜ë‚˜ì˜ ë…¸ë“œë¡œ ì—¬ê¸¸ ìˆ˜ ìžˆìŒ
virtual_node = 0
for generator in generators:
    union(parent, rank, virtual_node, generator)

# ìµœì†Œ ë¹„ìš©ì„ ìœ„í•œ ë³€ìˆ˜
min_cost = 0

# ëª¨ë“  ê°„ì„ ì„ ìˆœíšŒí•˜ë©´ì„œ
for u, v, w in edges:

    # ì‚¬ì´í´ì— ì†í•˜ì§€ ì•Šì•˜ë‹¤ë©´
    if find(parent, u) != find(parent, v):

        # í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ê³ , ìµœì†Œë¹„ìš©ì„ ë”í•¨
        union(parent, rank, u, v)
        min_cost += w

# ìµœì†Œë¹„ìš© ê³„ì‚°
print(min_cost)
```

### **ðŸ”–ì •ë¦¬**

1. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•  ë•Œ, ì¶œë°œ ë…¸ë“œê°€ ì—¬ëŸ¬ê°œë¼ë©´ í•˜ë‚˜ì˜ ë…¸ë“œë¡œ ë¬¶ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì•Œì•˜ë‹¤.