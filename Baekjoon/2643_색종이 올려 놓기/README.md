# [2643] 색종이 올려 놓기

### **난이도**
골드 4
## **📝문제**
크기가 모두 다른 직사각형 모양의 색종이가 여러 장 있다. 색종이를 하나씩 올려 놓아, 되도록 많은 장수의 색종이들을 쌓으려고 한다.

새로 한 장의 색종이를 올려 놓을 때는 지금까지 쌓아 놓은 색종이들 중 맨 위의 색종이 위에 올려놓아야 하며 아래의 두 조건을 모두 만족해야 한다.

조건 1 : 새로 올려 놓는 색종이는 맨 위의 색종이보다 크지 않아야 한다. 즉, 맨 위의 색종이 밖으로 나가지 않아야 한다.
조건 2 : 새로 올려 놓는 색종이와 맨 위의 색종이의 변들은 서로 평행해야 한다.(색종이를 90˚돌려 놓을 수 있다.)
예를 들어, 아래의 그림 중에서 위의 두 조건을 모두 만족하는 경우는 (나)뿐이다.

색종이는 두 변의 길이로 표현된다. (3, 5)는 두 변의 길이가 각각 3과 5인 색종이를 나타낸다. 예를 들어, 다음과 같이 7장의 색종이가 주어졌다고 하자 : (1, 2), (8, 7), (20, 10), (20, 20), (15, 12), (12, 14), (11, 12) 위의 조건을 만족하면서 가장 많이 쌓을 수 있는 색종이들의 순서는 (20, 20), (15, 12), (12, 14), (11, 12), (8, 7), (1, 2)이다.

입력으로 색종이들이 주어졌을 때, 위의 조건 1과 조건 2를 만족하면서 쌓을 수 있는 최대 색종이 장수를 구하는 프로그램을 작성하시오.
### **입력**
첫 번째 줄에는 색종이의 장수가 주어진다. 다음 줄부터 각 줄에 색종이의 두 변의 길이가 주어진다. 두 변의 길이는 한 칸 띄어 주어진다. 색종이의 최대 장수는 100이고, 각 변의 길이는 1000보다 작은 자연수이다.
### **출력**
쌓을 수 있는 최대 색종이 장수를 출력한다.
### **예제입출력**

**예제 입력1**

```
7
1 2
8 7
20 10
20 20
15 12
12 14
11 12
```

**예제 출력1**

```
6
```

### **출처**

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```python
N = int(input())

papers = []
for _ in range(N):
    a, b = map(int, input().split())
    w, h = min(a, b), max(a, b)
    papers.append((w, h))

papers.sort(key=lambda x: (-x[0], -x[1]))

dp = [1] * N

for i in range(N):
    for j in range(i):
        if papers[i][0] <= papers[j][0] and papers[i][1] <= papers[j][1]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
정답|32412|36|Python3|375
#### **📝해설**

**알고리즘**
```
1. DP
2. 정렬
```

### **다른 풀이**

```python
def solve():
    N = int(input())
    papers = sorted([sorted(map(int,input().split()),reverse = True) for _ in range(N)])
    heights = [h for _,h in papers]
    dp = [1] * N
    for i in range(1,N):
        for j in range(i):
            if heights[i] >= heights[j]:
                dp[i] = max(dp[i],dp[j]+1)
    return max(dp)

print(solve())
```

아이디 | 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:-----:|:----:|:--------:
syha|31120|32|Python3|347
#### **📝해설**

```python
N = int(input())

# 입력받기
papers = []
for _ in range(N):

    # 종이는 돌릴 수 있으니, 짧은 변, 긴 변이 되도록 입력
    a, b = map(int, input().split())
    w, h = min(a, b), max(a, b)
    papers.append((w, h))

# 종이를 각각 짧은 변, 긴 변을 기준으로 내림차순 정렬
papers.sort(key=lambda x: (-x[0], -x[1]))

# dp[i]: i번째 까지 쌓을 수 있는 종이의 수
dp = [1] * N

# 점화식
for i in range(N):

    # 이번 종이 기준으로, 앞의 종이를 몇개까지 쌓을 수 있는지 확인
    for j in range(i):

        # 종이가 더 작은 경우에만
        if papers[i][0] <= papers[j][0] and papers[i][1] <= papers[j][1]:

            # DP배열 갱신
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```