# [2179] ë¹„ìŠ·í•œ ë‹¨ì–´

### **ë‚œì´ë„**
ê³¨ë“œ 4
## **ðŸ“ë¬¸ì œ**
Nê°œì˜ ì˜ë‹¨ì–´ë“¤ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ìž¥ ë¹„ìŠ·í•œ ë‘ ë‹¨ì–´ë¥¼ êµ¬í•´ë‚´ëŠ” í”„ë¡œê·¸ëž¨ì„ ìž‘ì„±í•˜ì‹œì˜¤.

ë‘ ë‹¨ì–´ì˜ ë¹„ìŠ·í•œ ì •ë„ëŠ” ë‘ ë‹¨ì–´ì˜ ì ‘ë‘ì‚¬ì˜ ê¸¸ì´ë¡œ ì¸¡ì •í•œë‹¤. ì ‘ë‘ì‚¬ëž€ ë‘ ë‹¨ì–´ì˜ ì•žë¶€ë¶„ì—ì„œ ê³µí†µì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ë¶€ë¶„ë¬¸ìžì—´ì„ ë§í•œë‹¤. ì¦‰, ë‘ ë‹¨ì–´ì˜ ì•žì—ì„œë¶€í„° Mê°œì˜ ê¸€ìžë“¤ì´ ê°™ìœ¼ë©´ì„œ Mì´ ìµœëŒ€ì¸ ê²½ìš°ë¥¼ êµ¬í•˜ëŠ” ê²ƒì´ë‹¤. "AHEHHEH", "AHAHEH"ì˜ ì ‘ë‘ì‚¬ëŠ” "AH"ê°€ ë˜ê³ , "AB", "CD"ì˜ ì ‘ë‘ì‚¬ëŠ” ""(ê¸¸ì´ê°€ 0)ì´ ëœë‹¤.

ì ‘ë‘ì‚¬ì˜ ê¸¸ì´ê°€ ìµœëŒ€ì¸ ê²½ìš°ê°€ ì—¬ëŸ¬ ê°œì¼ ë•Œì—ëŠ” ìž…ë ¥ë˜ëŠ” ìˆœì„œëŒ€ë¡œ ì œì¼ ì•žìª½ì— ìžˆëŠ” ë‹¨ì–´ë¥¼ ë‹µìœ¼ë¡œ í•œë‹¤. ì¦‰, ë‹µìœ¼ë¡œ Së¼ëŠ” ë¬¸ìžì—´ê³¼ Të¼ëŠ” ë¬¸ìžì—´ì„ ì¶œë ¥í•œë‹¤ê³  í–ˆì„ ë•Œ, ìš°ì„  Sê°€ ìž…ë ¥ë˜ëŠ” ìˆœì„œëŒ€ë¡œ ì œì¼ ì•žìª½ì— ìžˆëŠ” ë‹¨ì–´ì¸ ê²½ìš°ë¥¼ ì¶œë ¥í•˜ê³ , ê·¸ëŸ° ê²½ìš°ë„ ì—¬ëŸ¬ ê°œ ìžˆì„ ë•Œì—ëŠ” ê·¸ ì¤‘ì—ì„œ Tê°€ ìž…ë ¥ë˜ëŠ” ìˆœì„œëŒ€ë¡œ ì œì¼ ì•žìª½ì— ìžˆëŠ” ë‹¨ì–´ì¸ ê²½ìš°ë¥¼ ì¶œë ¥í•œë‹¤.
### **ìž…ë ¥**
ì²«ì§¸ ì¤„ì— N(2 â‰¤ N â‰¤ 20,000)ì´ ì£¼ì–´ì§„ë‹¤. ë‹¤ìŒ Nê°œì˜ ì¤„ì— ì•ŒíŒŒë²³ ì†Œë¬¸ìžë¡œë§Œ ì´ë£¨ì–´ì§„ ê¸¸ì´ 100ìž ì´í•˜ì˜ ì„œë¡œ ë‹¤ë¥¸ ì˜ë‹¨ì–´ê°€ ì£¼ì–´ì§„ë‹¤.
### **ì¶œë ¥**
ì²«ì§¸ ì¤„ì— Së¥¼, ë‘˜ì§¸ ì¤„ì— Të¥¼ ì¶œë ¥í•œë‹¤. ë‹¨, ì´ ë‘ ë‹¨ì–´ëŠ” ì„œë¡œ ë‹¬ë¼ì•¼ í•œë‹¤. ì¦‰, ê°€ìž¥ ë¹„ìŠ·í•œ ë‘ ë‹¨ì–´ë¥¼ êµ¬í•  ë•Œ ê°™ì€ ë‹¨ì–´ëŠ” ì œì™¸í•˜ëŠ” ê²ƒì´ë‹¤.
### **ì˜ˆì œìž…ì¶œë ¥**

**ì˜ˆì œ ìž…ë ¥1**

```
9
noon
is
lunch
for
most
noone
waits
until
two
```

**ì˜ˆì œ ì¶œë ¥1**

```
noon
noone
```

**ì˜ˆì œ ìž…ë ¥2**

```
4
abcd
abe
abc
abchldp
```

**ì˜ˆì œ ì¶œë ¥2**

```
abcd
abc
```
### **ì¶œì²˜**

## **ðŸ§CODE REVIEW**

### **ðŸ§¾ë‚˜ì˜ í’€ì´**

```python
import sys

def common_prefix_length(s1, s2):
    length = min(len(s1), len(s2))
    for i in range(length):
        if s1[i] != s2[i]:
            return i
    return length

N = int(sys.stdin.readline().strip())
words = [(sys.stdin.readline().strip(), i) for i in range(N)]

max_similarity = -1
best_pair = None

for i in range(N - 1):
    for j in range(i + 1, N):
        s1, idx1 = words[i]
        s2, idx2 = words[j]
        similarity = common_prefix_length(s1, s2)

        if similarity > max_similarity:
            max_similarity = similarity
            best_pair = (s1, s2, idx1, idx2)

        elif similarity == max_similarity:
            if idx1 < best_pair[2] or (idx1 == best_pair[2] and idx2 < best_pair[3]):
                best_pair = (s1, s2, idx1, idx2)

print(best_pair[0])
print(best_pair[1])
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|113620|4868|PyPy3|820
#### **ðŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë¬¸ìžì—´
```

### **ë‹¤ë¥¸ í’€ì´**

```python
import sys
input = sys.stdin.readline


def solution():
    n = int(input())
    words = [input().rstrip() for _ in range(n)]
    answer = [[words[0], words[1]]]
    words_idx = {word: idx for idx, word in enumerate(words)}
    words.sort()
    max_len = 0

    for i in range(1, n):
        w1, w2 = words[i-1], words[i]
        if len(w1) < max_len or len(w2) < max_len:
            continue
        count = 0
        for x in range(min(len(w1), len(w2))):
            if w1[x] == w2[x]:
                count += 1
            else:
                break
        if count < max_len or count == 0:
            continue

        if count == max_len:
            if answer[-1][-1] == w1:
                answer[-1].append(w2)
            else:
                answer.append([w1, w2])
        elif count > max_len:
            max_len = count
            answer = [[w1, w2]]

    answer_idx = [sorted((words_idx[x], x) for x in lst) for lst in answer]
    answer_idx.sort()

    print(answer_idx[0][0][1])
    print(answer_idx[0][1][1])


solution()
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
to6289|33572|48|Python3|1048
#### **ðŸ“í•´ì„¤**

```python
import sys

# ë‘ ë¬¸ìžì—´ì—ì„œ ê³µí†µ ë¶€ë¶„ì˜ ê¸¸ì´ë¥¼ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜
def common_prefix_length(s1, s2):
    length = min(len(s1), len(s2))
    for i in range(length):
        if s1[i] != s2[i]:
            return i
    return length

# ë‹¨ì–´ë¥¼ ì¸ë±ìŠ¤ì™€ í•¨ê»˜ ì €ìž¥
N = int(sys.stdin.readline().strip())
words = [(sys.stdin.readline().strip(), i) for i in range(N)]

# ìµœëŒ€ ìœ ì‚¬ë„ì™€ ê·¸ ë•Œì˜ ë‹¨ì–´ ìŒ
max_similarity = -1
best_pair = None

# ëª¨ë“  ë‹¨ì–´ë“¤ì„ ë¹„êµ
for i in range(N - 1):
    for j in range(i + 1, N):
        s1, idx1 = words[i]
        s2, idx2 = words[j]
        similarity = common_prefix_length(s1, s2)

        if similarity > max_similarity:
            max_similarity = similarity
            best_pair = (s1, s2, idx1, idx2)

        elif similarity == max_similarity:
            if idx1 < best_pair[2] or (idx1 == best_pair[2] and idx2 < best_pair[3]):
                best_pair = (s1, s2, idx1, idx2)

print(best_pair[0])
print(best_pair[1])
```

### **ðŸ”–ì •ë¦¬**

1. ìµœì í™”ë¥¼ ìž˜í•˜ìž