# [ë¬¸ì œë²ˆí˜¸] ë¬¸ì œì œëª©

### **ë‚œì´ë„**
ê³¨ë“œ 3
## **ğŸ“ë¬¸ì œ**
N(2 â‰¤ N â‰¤ 10,000)ê°œì˜ ì„¬ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë‚˜ë¼ê°€ ìˆë‹¤. ì´ë“¤ ì¤‘ ëª‡ ê°œì˜ ì„¬ ì‚¬ì´ì—ëŠ” ë‹¤ë¦¬ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì–´ì„œ ì°¨ë“¤ì´ ë‹¤ë‹ ìˆ˜ ìˆë‹¤.

ì˜ì‹ ì¤‘ê³µì—…ì—ì„œëŠ” ë‘ ê°œì˜ ì„¬ì— ê³µì¥ì„ ì„¸ì›Œ ë‘ê³  ë¬¼í’ˆì„ ìƒì‚°í•˜ëŠ” ì¼ì„ í•˜ê³  ìˆë‹¤. ë¬¼í’ˆì„ ìƒì‚°í•˜ë‹¤ ë³´ë©´ ê³µì¥ì—ì„œ ë‹¤ë¥¸ ê³µì¥ìœ¼ë¡œ ìƒì‚° ì¤‘ì´ë˜ ë¬¼í’ˆì„ ìˆ˜ì†¡í•´ì•¼ í•  ì¼ì´ ìƒê¸°ê³¤ í•œë‹¤. ê·¸ëŸ°ë° ê°ê°ì˜ ë‹¤ë¦¬ë§ˆë‹¤ ì¤‘ëŸ‰ì œí•œì´ ìˆê¸° ë•Œë¬¸ì— ë¬´í„±ëŒ€ê³  ë¬¼í’ˆì„ ì˜®ê¸¸ ìˆœ ì—†ë‹¤. ë§Œì•½ ì¤‘ëŸ‰ì œí•œì„ ì´ˆê³¼í•˜ëŠ” ì–‘ì˜ ë¬¼í’ˆì´ ë‹¤ë¦¬ë¥¼ ì§€ë‚˜ê²Œ ë˜ë©´ ë‹¤ë¦¬ê°€ ë¬´ë„ˆì§€ê²Œ ëœë‹¤.

í•œ ë²ˆì˜ ì´ë™ì—ì„œ ì˜®ê¸¸ ìˆ˜ ìˆëŠ” ë¬¼í’ˆë“¤ì˜ ì¤‘ëŸ‰ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
### **ì…ë ¥**
ì²«ì§¸ ì¤„ì— N, M(1 â‰¤ M â‰¤ 100,000)ì´ ì£¼ì–´ì§„ë‹¤. ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ë‹¤ë¦¬ì— ëŒ€í•œ ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì„¸ ì •ìˆ˜ A, B(1 â‰¤ A, B â‰¤ N), C(1 â‰¤ C â‰¤ 1,000,000,000)ê°€ ì£¼ì–´ì§„ë‹¤. ì´ëŠ” Aë²ˆ ì„¬ê³¼ Bë²ˆ ì„¬ ì‚¬ì´ì— ì¤‘ëŸ‰ì œí•œì´ Cì¸ ë‹¤ë¦¬ê°€ ì¡´ì¬í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. ì„œë¡œ ê°™ì€ ë‘ ì„¬ ì‚¬ì´ì— ì—¬ëŸ¬ ê°œì˜ ë‹¤ë¦¬ê°€ ìˆì„ ìˆ˜ë„ ìˆìœ¼ë©°, ëª¨ë“  ë‹¤ë¦¬ëŠ” ì–‘ë°©í–¥ì´ë‹¤. ë§ˆì§€ë§‰ ì¤„ì—ëŠ” ê³µì¥ì´ ìœ„ì¹˜í•´ ìˆëŠ” ì„¬ì˜ ë²ˆí˜¸ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì„œë¡œ ë‹¤ë¥¸ ë‘ ì •ìˆ˜ê°€ ì£¼ì–´ì§„ë‹¤. ê³µì¥ì´ ìˆëŠ” ë‘ ì„¬ì„ ì—°ê²°í•˜ëŠ” ê²½ë¡œëŠ” í•­ìƒ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ë§Œ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.
### **ì¶œë ¥**
ì²«ì§¸ ì¤„ì— ë‹µì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
3 3
1 2 2
3 1 3
2 3 2
1 3
```

**ì˜ˆì œ ì¶œë ¥1**

```
3
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
import sys
from heapq import heappush, heappop

INF = float('inf')

N, M = map(int, sys.stdin.readline().rstrip().split())
edges = [[] for _ in range(N+1)]

for _ in range(M):
    a, b, c = map(int, sys.stdin.readline().rstrip().split())
    edges[a].append((c, b))
    edges[b].append((c, a))

start, end = map(int, sys.stdin.readline().rstrip().split())
weights = [0] * (N + 1)
weights[start] = INF

pq = [(-INF, start)]
while pq:
    
    now_weight, now_node = heappop(pq)
    now_weight *= -1

    if now_node == end:
        print(now_weight)
        break

    if now_weight < weights[now_node]:
        continue

    for next_weight, next_node in edges[now_node]:
        next_capacity = min(now_weight, next_weight)
        if next_capacity > weights[next_node]:
            weights[next_node] = next_capacity
            heappush(pq, (-next_capacity, next_node))
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|124952|236|PyPy3|872
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. DFS/BFS
2. ì´ë¶„ íƒìƒ‰
3. ë‹¤ìµìŠ¤íŠ¸ë¼
4. ë¶„ë¦¬ì§‘í•©
```

### **ë‹¤ë¥¸ í’€ì´**

```python
import sys
input = sys.stdin.readline

def init():
    for _ in range(m):
        a, b, w = map(int, input().split())
        legs.append((w, a, b))
    legs.sort(reverse=True)

def find(x):
    if x == parent[x]:
        return x

    parent[x] = find(parent[x])
    return parent[x]

def union(a, b):
    x = find(a)
    y = find(b)

    if x < y: parent[y] = x
    else: parent[x] = y


n, m = map(int, input().split())
legs = []
init()

parent = [i for i in range(n+1)]
s, e = map(int, input().split())

for w, a, b in legs:
    union(a, b)

    if find(s) == find(e):
        print(w)
        break
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
ever618|49576|184|Python3|603
#### **ğŸ“í•´ì„¤**

```python
import sys
from heapq import heappush, heappop

INF = float('inf')

N, M = map(int, sys.stdin.readline().rstrip().split())
edges = [[] for _ in range(N+1)]

# ê°„ì„  ì •ë³´ ì…ë ¥
for _ in range(M):
    a, b, c = map(int, sys.stdin.readline().rstrip().split())
    edges[a].append((c, b))
    edges[b].append((c, a))

# ì‹œì‘ì , ëì 
start, end = map(int, sys.stdin.readline().rstrip().split())

# í•´ë‹¹ ë…¸ë“œë¥¼ ì§€ë‚  ë•Œ ê°€ëŠ¥í•œ ìµœëŒ€ ìš©ëŸ‰
weights = [0] * (N + 1)

# ì‹œì‘ì  ì´ˆê¸°í™”
weights[start] = INF

# ìµœëŒ€ í™ì„ ì‚¬ìš©
pq = [(-INF, start)]

while pq:
    
    now_weight, now_node = heappop(pq)
    now_weight *= -1

    # ë„ì°©ì§€ì— ë‹¿ì•˜ë‹¤ë©´ ì¢…ë£Œ
    if now_node == end:
        print(now_weight)
        break
    
    # ìµœëŒ€ìš©ëŸ‰ë³´ë‹¤ ì‘ì€ ìƒíƒœë¼ë©´ ê³ ë ¤í•˜ì§€ ì•ŠìŒ
    if now_weight < weights[now_node]:
        continue

    # ë‹¤ìŒ ë…¸ë“œë¥¼ í™•ì¸í•˜ë©´ì„œ
    for next_weight, next_node in edges[now_node]:

        # ê°€ëŠ¥í•œ ìµœëŒ€ ìš©ëŸ‰ì„ êµ¬í•¨
        next_capacity = min(now_weight, next_weight)

        # ê°€ëŠ¥í•œ ê²½ìš°, íƒìƒ‰
        if next_capacity > weights[next_node]:
            weights[next_node] = next_capacity
            heappush(pq, (-next_capacity, next_node))
```

### **ğŸ”–ì •ë¦¬**

1. ê°„ì„ ì„ ì •ë ¬í•˜ê³  ë¶„ë¦¬ì§‘í•© ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ ìˆì—ˆë‹¤