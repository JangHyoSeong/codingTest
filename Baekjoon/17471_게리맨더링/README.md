# [17471] ê²Œë¦¬ë©˜ë”ë§

### **ë‚œì´ë„**
ê³¨ë“œ 3
## **ğŸ“ë¬¸ì œ**
ë°±ì¤€ì‹œì˜ ì‹œì¥ ìµœë°±ì¤€ì€ ì§€ë‚œ ëª‡ ë…„ê°„ ê²Œë¦¬ë§¨ë”ë§ì„ í†µí•´ì„œ ìì‹ ì˜ ë‹¹ì—ê²Œ ìœ ë¦¬í•˜ê²Œ ì„ ê±°êµ¬ë¥¼ íšì •í–ˆë‹¤. ê²¬ì œí•  ê¶Œë ¥ì´ ì—†ì–´ì§„ ìµœë°±ì¤€ì€ ê¶Œë ¥ì„ ë§¤ìš° ë¶€ë‹¹í•˜ê²Œ í–‰ì‚¬í–ˆê³ , ì‹¬ì§€ì–´ëŠ” ì‹œì˜ ì´ë¦„ë„ ë°±ì¤€ì‹œë¡œ ë³€ê²½í–ˆë‹¤. ì´ë²ˆ ì„ ê±°ì—ì„œëŠ” ìµœëŒ€í•œ ê³µí‰í•˜ê²Œ ì„ ê±°êµ¬ë¥¼ íšì •í•˜ë ¤ê³  í•œë‹¤.

ë°±ì¤€ì‹œëŠ” Nê°œì˜ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆê³ , êµ¬ì—­ì€ 1ë²ˆë¶€í„° Në²ˆê¹Œì§€ ë²ˆí˜¸ê°€ ë§¤ê²¨ì ¸ ìˆë‹¤. êµ¬ì—­ì„ ë‘ ê°œì˜ ì„ ê±°êµ¬ë¡œ ë‚˜ëˆ ì•¼ í•˜ê³ , ê° êµ¬ì—­ì€ ë‘ ì„ ê±°êµ¬ ì¤‘ í•˜ë‚˜ì— í¬í•¨ë˜ì–´ì•¼ í•œë‹¤. ì„ ê±°êµ¬ëŠ” êµ¬ì—­ì„ ì ì–´ë„ í•˜ë‚˜ í¬í•¨í•´ì•¼ í•˜ê³ , í•œ ì„ ê±°êµ¬ì— í¬í•¨ë˜ì–´ ìˆëŠ” êµ¬ì—­ì€ ëª¨ë‘ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤. êµ¬ì—­ Aì—ì„œ ì¸ì ‘í•œ êµ¬ì—­ì„ í†µí•´ì„œ êµ¬ì—­ Bë¡œ ê°ˆ ìˆ˜ ìˆì„ ë•Œ, ë‘ êµ¬ì—­ì€ ì—°ê²°ë˜ì–´ ìˆë‹¤ê³  í•œë‹¤. ì¤‘ê°„ì— í†µí•˜ëŠ” ì¸ì ‘í•œ êµ¬ì—­ì€ 0ê°œ ì´ìƒì´ì–´ì•¼ í•˜ê³ , ëª¨ë‘ ê°™ì€ ì„ ê±°êµ¬ì— í¬í•¨ëœ êµ¬ì—­ì´ì–´ì•¼ í•œë‹¤.

ì•„ë˜ ê·¸ë¦¼ì€ 6ê°œì˜ êµ¬ì—­ì´ ìˆëŠ” ê²ƒì´ê³ , ì¸ì ‘í•œ êµ¬ì—­ì€ ì„ ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆë‹¤.

[ì´ë¯¸ì§€](https://upload.acmicpc.net/08218f4c-2653-4861-a4c1-e7ce808f3a85/-/preview/)

ê³µí‰í•˜ê²Œ ì„ ê±°êµ¬ë¥¼ ë‚˜ëˆ„ê¸° ìœ„í•´ ë‘ ì„ ê±°êµ¬ì— í¬í•¨ëœ ì¸êµ¬ì˜ ì°¨ì´ë¥¼ ìµœì†Œë¡œ í•˜ë ¤ê³  í•œë‹¤. ë°±ì¤€ì‹œì˜ ì •ë³´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì¸êµ¬ ì°¨ì´ì˜ ìµœì†Ÿê°’ì„ êµ¬í•´ë³´ì.
### **ì…ë ¥**
ì²«ì§¸ ì¤„ì— êµ¬ì—­ì˜ ê°œìˆ˜ Nì´ ì£¼ì–´ì§„ë‹¤. ë‘˜ì§¸ ì¤„ì— êµ¬ì—­ì˜ ì¸êµ¬ê°€ 1ë²ˆ êµ¬ì—­ë¶€í„° Në²ˆ êµ¬ì—­ê¹Œì§€ ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§„ë‹¤. ì¸êµ¬ëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ì ¸ ìˆë‹¤.

ì…‹ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ê° êµ¬ì—­ê³¼ ì¸ì ‘í•œ êµ¬ì—­ì˜ ì •ë³´ê°€ ì£¼ì–´ì§„ë‹¤. ê° ì •ë³´ì˜ ì²« ë²ˆì§¸ ì •ìˆ˜ëŠ” ê·¸ êµ¬ì—­ê³¼ ì¸ì ‘í•œ êµ¬ì—­ì˜ ìˆ˜ì´ê³ , ì´í›„ ì¸ì ‘í•œ êµ¬ì—­ì˜ ë²ˆí˜¸ê°€ ì£¼ì–´ì§„ë‹¤. ëª¨ë“  ê°’ì€ ì •ìˆ˜ë¡œ êµ¬ë¶„ë˜ì–´ì ¸ ìˆë‹¤.

êµ¬ì—­ Aê°€ êµ¬ì—­ Bì™€ ì¸ì ‘í•˜ë©´ êµ¬ì—­ Bë„ êµ¬ì—­ Aì™€ ì¸ì ‘í•˜ë‹¤. ì¸ì ‘í•œ êµ¬ì—­ì´ ì—†ì„ ìˆ˜ë„ ìˆë‹¤.
### **ì¶œë ¥**
ì²«ì§¸ ì¤„ì— ë°±ì¤€ì‹œë¥¼ ë‘ ì„ ê±°êµ¬ë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ, ë‘ ì„ ê±°êµ¬ì˜ ì¸êµ¬ ì°¨ì´ì˜ ìµœì†Ÿê°’ì„ ì¶œë ¥í•œë‹¤. ë‘ ì„ ê±°êµ¬ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ëŠ” -1ì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
6
5 2 3 4 1 2
2 2 4
4 1 3 6 5
2 4 2
2 1 3
1 2
1 2
```

**ì˜ˆì œ ì¶œë ¥1**

```
1
```

**ì˜ˆì œ ì…ë ¥2**

```
6
1 1 1 1 1 1
2 2 4
4 1 3 6 5
2 4 2
2 1 3
1 2
1 2
```

**ì˜ˆì œ ì¶œë ¥2**

```
0
```

**ì˜ˆì œ ì…ë ¥3**

```
6
10 20 10 20 30 40
0
0
0
0
0
0
```

**ì˜ˆì œ ì¶œë ¥3**

```
-1
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
from itertools import combinations
from collections import deque

N = int(input())
populations = [0] + list(map(int, input().split()))

edges = [[] for _ in range(N+1)]
for i in range(1, N+1):
    data = list(map(int, input().split()))
    edges[i] = data[1:]

min_population = int(21e8)

for i in range(1, N//2 + 1):
    for subset in combinations(range(1, N+1), i):
        area1 = set(subset)
        area2 = set(range(1, N+1)) - area1

        queue = deque([next(iter(area1))])
        visited = set(queue)

        while queue:
            node = queue.popleft()
            for neighbor in edges[node]:
                if neighbor in area1 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        if visited != area1:
            continue

        queue = deque([next(iter(area2))])
        visited = set(queue)
        while queue:
            node = queue.popleft()
            for neighbor in edges[node]:
                if neighbor in area2 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        if visited != area2:
            continue

        pop1 = sum(populations[i] for i in area1)
        pop2 = sum(populations[i] for i in area2)
        min_population = min(min_population, abs(pop1 - pop2))

print(min_population if min_population != int(21e8) else -1)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|36040|64|Python3|1417
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë¸Œë£¨íƒˆí¬ìŠ¤
2. ì¡°í•©
```

### **ë‹¤ë¥¸ í’€ì´**

```python
from itertools import combinations

def bfs(comb):
    Q = [comb[0]]
    visited = [0] * (N+1)
    visited[comb[0]] = 1
    cnt = 1
    people = population[comb[0]]

    while Q:
        temp = Q.pop(0)
        for w in adj_lst[temp]:
            if visited[w] == 0 and w in comb:
                Q.append(w)
                visited[w] = 1
                cnt += 1
                people += population[w]

    return people, cnt


N = int(input())
population = [0] + list(map(int,input().split()))
adj_lst = [[] for _ in range(N+1)]
result = 1001
for i in range(1,N+1):
    temp = list(map(int,input().split()))
    adj_lst[i] = temp[1:]

for i in range(1,N//2+1):
    comb_lst = list(combinations(range(1,N+1),i))
    for comb in comb_lst:
        people1, cnt1 = bfs(comb)

        comb_2 = []
        for x in range(1,N+1):
            if x not in comb:
                comb_2.append(x)
        people2, cnt2 = bfs(comb_2)

        if cnt1 + cnt2 == N:
            result = min(result, abs(people2 - people1))

if result != 1001:
    print(result)
else:
    print(-1)
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
taktak33|31120|36|Python3|1070
#### **ğŸ“í•´ì„¤**

```python
from itertools import combinations
from collections import deque

# ì…ë ¥ë°›ìŒ
N = int(input())
populations = [0] + list(map(int, input().split()))

# ê°„ì„  ì •ë³´ ì €ì¥
edges = [[] for _ in range(N+1)]
for i in range(1, N+1):
    data = list(map(int, input().split()))
    edges[i] = data[1:]

# ìµœì†Œ ì¸êµ¬ì°¨ì´ë¥¼ ì €ì¥í•  ë³€ìˆ˜
min_population = int(21e8)

# ëª¨ë“  ì§€ì—­êµ¬ë¥¼ ë‘ ì§‘í•©ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ìœ„í•œ ë°˜ë³µ
for i in range(1, N//2 + 1):
    # ì›ì†Œê°€ iê°œì¸ ì¡°í•©ì„ ìƒì„±
    for subset in combinations(range(1, N+1), i):
        # êµ¬ì—­ 1
        area1 = set(subset)
        # êµ¬ì—­ 2
        area2 = set(range(1, N+1)) - area1

        # êµ¬ì—­ 1ì—ì„œ ì„ì˜ì˜ í•œ ì§€ì—­ì„ ì„ íƒ
        queue = deque([next(iter(area1))])

        # BFS
        visited = set(queue)

        while queue:
            node = queue.popleft()
            for neighbor in edges[node]:
                if neighbor in area1 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        # êµ¬ì—­ì„ ëª¨ë‘ ë°©ë¬¸í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ê³ ë ¤í•˜ì§€ ì•ŠìŒ
        if visited != area1:
            continue

        # êµ¬ì—­ 2ë„ ë˜‘ê°™ì´ BFS
        queue = deque([next(iter(area2))])
        visited = set(queue)
        while queue:
            node = queue.popleft()
            for neighbor in edges[node]:
                if neighbor in area2 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        if visited != area2:
            continue
        
        # ë‘ êµ¬ì—­ì˜ ì¸êµ¬ì°¨ë¥¼ êµ¬í•œ ë’¤ ê°±ì‹ 
        pop1 = sum(populations[i] for i in area1)
        pop2 = sum(populations[i] for i in area2)
        min_population = min(min_population, abs(pop1 - pop2))

# ì¶œë ¥
print(min_population if min_population != int(21e8) else -1)
```