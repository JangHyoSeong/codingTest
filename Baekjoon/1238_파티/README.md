# [1238] íŒŒí‹°

### **ë‚œì´ë„**
ê³¨ë“œ 3
## **ğŸ“ë¬¸ì œ**
Nê°œì˜ ìˆ«ìë¡œ êµ¬ë¶„ëœ ê°ê°ì˜ ë§ˆì„ì— í•œ ëª…ì˜ í•™ìƒì´ ì‚´ê³  ìˆë‹¤.

ì–´ëŠ ë‚  ì´ Nëª…ì˜ í•™ìƒì´ X (1 â‰¤ X â‰¤ N)ë²ˆ ë§ˆì„ì— ëª¨ì—¬ì„œ íŒŒí‹°ë¥¼ ë²Œì´ê¸°ë¡œ í–ˆë‹¤. ì´ ë§ˆì„ ì‚¬ì´ì—ëŠ” ì´ Mê°œì˜ ë‹¨ë°©í–¥ ë„ë¡œë“¤ì´ ìˆê³  ië²ˆì§¸ ê¸¸ì„ ì§€ë‚˜ëŠ”ë° Ti(1 â‰¤ Ti â‰¤ 100)ì˜ ì‹œê°„ì„ ì†Œë¹„í•œë‹¤.

ê°ê°ì˜ í•™ìƒë“¤ì€ íŒŒí‹°ì— ì°¸ì„í•˜ê¸° ìœ„í•´ ê±¸ì–´ê°€ì„œ ë‹¤ì‹œ ê·¸ë“¤ì˜ ë§ˆì„ë¡œ ëŒì•„ì™€ì•¼ í•œë‹¤. í•˜ì§€ë§Œ ì´ í•™ìƒë“¤ì€ ì›Œë‚™ ê²Œì„ëŸ¬ì„œ ìµœë‹¨ ì‹œê°„ì— ì˜¤ê³  ê°€ê¸°ë¥¼ ì›í•œë‹¤.

ì´ ë„ë¡œë“¤ì€ ë‹¨ë°©í–¥ì´ê¸° ë•Œë¬¸ì— ì•„ë§ˆ ê·¸ë“¤ì´ ì˜¤ê³  ê°€ëŠ” ê¸¸ì´ ë‹¤ë¥¼ì§€ë„ ëª¨ë¥¸ë‹¤. Nëª…ì˜ í•™ìƒë“¤ ì¤‘ ì˜¤ê³  ê°€ëŠ”ë° ê°€ì¥ ë§ì€ ì‹œê°„ì„ ì†Œë¹„í•˜ëŠ” í•™ìƒì€ ëˆ„êµ¬ì¼ì§€ êµ¬í•˜ì—¬ë¼.
### **ì…ë ¥**
ì²«ì§¸ ì¤„ì— N(1 â‰¤ N â‰¤ 1,000), M(1 â‰¤ M â‰¤ 10,000), Xê°€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì…ë ¥ëœë‹¤. ë‘ ë²ˆì§¸ ì¤„ë¶€í„° M+1ë²ˆì§¸ ì¤„ê¹Œì§€ ië²ˆì§¸ ë„ë¡œì˜ ì‹œì‘ì , ëì , ê·¸ë¦¬ê³  ì´ ë„ë¡œë¥¼ ì§€ë‚˜ëŠ”ë° í•„ìš”í•œ ì†Œìš”ì‹œê°„ Tiê°€ ë“¤ì–´ì˜¨ë‹¤. ì‹œì‘ì ê³¼ ëì ì´ ê°™ì€ ë„ë¡œëŠ” ì—†ìœ¼ë©°, ì‹œì‘ì ê³¼ í•œ ë„ì‹œ Aì—ì„œ ë‹¤ë¥¸ ë„ì‹œ Bë¡œ ê°€ëŠ” ë„ë¡œì˜ ê°œìˆ˜ëŠ” ìµœëŒ€ 1ê°œì´ë‹¤.

ëª¨ë“  í•™ìƒë“¤ì€ ì§‘ì—ì„œ Xì— ê°ˆìˆ˜ ìˆê³ , Xì—ì„œ ì§‘ìœ¼ë¡œ ëŒì•„ì˜¬ ìˆ˜ ìˆëŠ” ë°ì´í„°ë§Œ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.
### **ì¶œë ¥**
ì²« ë²ˆì§¸ ì¤„ì— Nëª…ì˜ í•™ìƒë“¤ ì¤‘ ì˜¤ê³  ê°€ëŠ”ë° ê°€ì¥ ì˜¤ë˜ ê±¸ë¦¬ëŠ” í•™ìƒì˜ ì†Œìš”ì‹œê°„ì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
4 8 2
1 2 4
1 3 2
1 4 7
2 1 1
2 3 5
3 1 2
3 4 4
4 2 3
```

**ì˜ˆì œ ì¶œë ¥1**

```
10
```

### **ì¶œì²˜**
Olympiad > USA Computing Olympiad > 2006-2007 Season > USACO February 2007 Contest > Silver 3ë²ˆ
## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
from heapq import heappop, heappush
INF = 21e8

def dijkstra(start, target):

    distance = [INF] * (N+1)
    distance[start] = 0
    
    pq = []
    heappush(pq, (0, start))
    
    while pq:
        dist, now = heappop(pq)

        if distance[now] < dist:
            continue

        for to in graph[now]:
            next_node, next_dist = to[0], to[1]
            new_dist = next_dist + dist
            
            if new_dist >= distance[next_node]:
                continue

            distance[next_node] = new_dist
            heappush(pq, (new_dist, next_node))

    return distance[target]

N, M, X = map(int, input().split())
graph = [[] for _ in range(N+1)]

for _ in range(M):
    s, e, t = map(int, input().split())
    graph[s].append((e, t))

max_time = 0
for i in range(1, N+1):
    temp_time_go = dijkstra(i, X)
    temp_time_back = dijkstra(X, i)

    max_time = max(max_time, temp_time_back + temp_time_go)

print(max_time)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|34212|1848|Python3|952
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë‹¤ì´ìŠ¤íŠ¸ë¼
```

### **ë‹¤ë¥¸ í’€ì´**

```python
import sys
import heapq

n, m, x = map(int, sys.stdin.readline().split())
n_routes = [[] for _ in range(n+1)]
r_routes = [[] for _ in range(n+1)]
n_visit = [-1] * (n+1)
r_visit = [-1] * (n+1)

for i in range(m):
    s, e, w = map(int, sys.stdin.readline().split())
    n_routes[s].append((w, e))
    r_routes[e].append((w, s))

hq = n_routes[x]
n_visit[x] = 0
heapq.heapify(hq)

while hq:
    w, v = heapq.heappop(hq)
    if n_visit[v] != -1:
        continue
    n_visit[v] = w
    for ww, vv in n_routes[v]:
        if n_visit[vv] == -1:
            heapq.heappush(hq, (ww+w, vv))


hq = r_routes[x]
r_visit[x] = 0
heapq.heapify(hq)
while hq:
    w, v = heapq.heappop(hq)
    if r_visit[v] != -1:
        continue
    r_visit[v] = w
    for ww, vv in r_routes[v]:
        if r_visit[vv] == -1:
            heapq.heappush(hq, (ww+w, vv))

min_d = r_visit[1] + n_visit[1]
for i in range(2, n+1, 1):
    min_d = max(min_d, r_visit[i] + n_visit[i])
print(min_d)
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
20230660|34236|52|Python3|959
#### **ğŸ“í•´ì„¤**

```python
from heapq import heappop, heappush
INF = 21e8

def dijkstra(start, target):
    # ëª©í‘œì§€ì ê¹Œì§€ ìµœë‹¨ê±°ë¦¬ë¥¼ ì°¾ëŠ” ë‹¤ì´ìŠ¤íŠ¸ë¼ í•¨ìˆ˜
    distance = [INF] * (N+1)
    distance[start] = 0
    
    pq = []
    heappush(pq, (0, start))
    
    while pq:
        dist, now = heappop(pq)

        if distance[now] < dist:
            continue

        for to in graph[now]:
            next_node, next_dist = to[0], to[1]
            new_dist = next_dist + dist
            
            if new_dist >= distance[next_node]:
                continue

            distance[next_node] = new_dist
            heappush(pq, (new_dist, next_node))

    return distance[target]

N, M, X = map(int, input().split())
graph = [[] for _ in range(N+1)]

# ê°„ì„  ì •ë³´ë¥¼ ì €ì¥
for _ in range(M):
    s, e, t = map(int, input().split())
    graph[s].append((e, t))

max_time = 0
# ëª¨ë“  ë…¸ë“œì—ì„œë¶€í„° Xë…¸ë“œë¥¼ ë‹¤ë…€ì˜¤ëŠ”ë° ê±¸ë¦¬ëŠ” ê±°ë¦¬ë¥¼ ì¸¡ì •
for i in range(1, N+1):
    temp_time_go = dijkstra(i, X)
    temp_time_back = dijkstra(X, i)

    max_time = max(max_time, temp_time_back + temp_time_go)

print(max_time)
```