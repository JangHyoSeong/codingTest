# [9370] ë¯¸í™•ì¸ ë„ì°©ì§€

### **ë‚œì´ë„**
ê³¨ë“œ 2
## **ğŸ“ë¬¸ì œ**
(ì·¨ìµ)B100 ìš”ì›, ìš”ë€í•œ ì˜·ì°¨ë¦¼ì„ í•œ ì„œì»¤ìŠ¤ ì˜ˆìˆ ê°€ í•œ ìŒì´ í•œ ë„ì‹œì˜ ê±°ë¦¬ë“¤ì„ ì´ë™í•˜ê³  ìˆë‹¤. ë„ˆì˜ ì„ë¬´ëŠ” ê·¸ë“¤ì´ ì–´ë””ë¡œ ê°€ê³  ìˆëŠ”ì§€ ì•Œì•„ë‚´ëŠ” ê²ƒì´ë‹¤. ìš°ë¦¬ê°€ ì•Œì•„ë‚¸ ê²ƒì€ ê·¸ë“¤ì´ sì§€ì ì—ì„œ ì¶œë°œí–ˆë‹¤ëŠ” ê²ƒ, ê·¸ë¦¬ê³  ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ í•˜ë‚˜ê°€ ê·¸ë“¤ì˜ ëª©ì ì§€ë¼ëŠ” ê²ƒì´ë‹¤. ê·¸ë“¤ì´ ê¸‰í•œ ìƒí™©ì´ê¸° ë•Œë¬¸ì— ëª©ì ì§€ê¹Œì§€ ìš°íšŒí•˜ì§€ ì•Šê³  ìµœë‹¨ê±°ë¦¬ë¡œ ê°ˆ ê²ƒì´ë¼ í™•ì‹ í•œë‹¤. ì´ìƒì´ë‹¤. (ì·¨ìµ)

ì–´íœ´! (ìš”ë€í•œ ì˜·ì°¨ë¦¼ì„ í–ˆì„ì§€ë„ ëª¨ë¥¼) ë“€ì˜¤ê°€ ì–´ë””ì—ë„ ë³´ì´ì§€ ì•ŠëŠ”ë‹¤. ë‹¤í–‰íˆë„ ë‹¹ì‹ ì€ í›„ê°ì´ ê°œë§Œí¼ ë›°ì–´ë‚˜ë‹¤. ì´ í›„ê°ìœ¼ë¡œ ê·¸ë“¤ì´ gì™€ h êµì°¨ë¡œ ì‚¬ì´ì— ìˆëŠ” ë„ë¡œë¥¼ ì§€ë‚˜ê°”ë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆë‹¤.

ì´ ë“€ì˜¤ëŠ” ëŒ€ì²´ ì–´ë””ë¡œ ê°€ê³  ìˆëŠ” ê²ƒì¼ê¹Œ?

![ì´ë¯¸ì§€](https://www.acmicpc.net/upload/images/destination.png)

ì˜ˆì œ ì…ë ¥ì˜ ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ë¥¼ ì‹œê°í™”í•œ ê²ƒì´ë‹¤. ì´ ë“€ì˜¤ëŠ” íšŒìƒ‰ ì›ì—ì„œ ë‘ ê²€ì€ ì› ì¤‘ í•˜ë‚˜ë¡œ ê°€ê³  ìˆê³  ì ì„ ìœ¼ë¡œ í‘œì‹œëœ ë„ë¡œì—ì„œ ëƒ„ìƒˆë¥¼ ë§¡ì•˜ë‹¤. ë”°ë¼ì„œ ê·¸ë“¤ì€ 6ìœ¼ë¡œ í–¥í•˜ê³  ìˆë‹¤.
### **ì…ë ¥**
ì²« ë²ˆì§¸ ì¤„ì—ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ T(1 â‰¤ T â‰¤ 100)ê°€ ì£¼ì–´ì§„ë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤

- ì²« ë²ˆì§¸ ì¤„ì— 3ê°œì˜ ì •ìˆ˜ n, m, t (2 â‰¤ n â‰¤ 2 000, 1 â‰¤ m â‰¤ 50 000 and 1 â‰¤ t â‰¤ 100)ê°€ ì£¼ì–´ì§„ë‹¤. ê°ê° êµì°¨ë¡œ, ë„ë¡œ, ëª©ì ì§€ í›„ë³´ì˜ ê°œìˆ˜ì´ë‹¤.
- ë‘ ë²ˆì§¸ ì¤„ì— 3ê°œì˜ ì •ìˆ˜ s, g, h (1 â‰¤ s, g, h â‰¤ n)ê°€ ì£¼ì–´ì§„ë‹¤. sëŠ” ì˜ˆìˆ ê°€ë“¤ì˜ ì¶œë°œì§€ì´ê³ , g, hëŠ” ë¬¸ì œ ì„¤ëª…ì— ë‚˜ì™€ ìˆë‹¤. (g â‰  h)
- ê·¸ ë‹¤ìŒ mê°œì˜ ê° ì¤„ë§ˆë‹¤ 3ê°œì˜ ì •ìˆ˜ a, b, d (1 â‰¤ a < b â‰¤ n and 1 â‰¤ d â‰¤ 1 000)ê°€ ì£¼ì–´ì§„ë‹¤. aì™€ b ì‚¬ì´ì— ê¸¸ì´ dì˜ ì–‘ë°©í–¥ ë„ë¡œê°€ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤.
- ê·¸ ë‹¤ìŒ tê°œì˜ ê° ì¤„ë§ˆë‹¤ ì •ìˆ˜ xê°€ ì£¼ì–´ì§€ëŠ”ë°, tê°œì˜ ëª©ì ì§€ í›„ë³´ë“¤ì„ ì˜ë¯¸í•œë‹¤. ì´ tê°œì˜ ì§€ì ë“¤ì€ ì„œë¡œ ë‹¤ë¥¸ ìœ„ì¹˜ì´ë©° ëª¨ë‘ sì™€ ê°™ì§€ ì•Šë‹¤.

êµì°¨ë¡œ ì‚¬ì´ì—ëŠ” ë„ë¡œê°€ ë§ì•„ë´ì•¼ 1ê°œì´ë‹¤. mê°œì˜ ì¤„ ì¤‘ì—ì„œ gì™€ h ì‚¬ì´ì˜ ë„ë¡œë¥¼ ë‚˜íƒ€ë‚¸ ê²ƒì´ ì¡´ì¬í•œë‹¤. ë˜í•œ ì´ ë„ë¡œëŠ” ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ ì ì–´ë„ 1ê°œë¡œ í–¥í•˜ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ì¼ë¶€ì´ë‹¤.
### **ì¶œë ¥**
í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤

ì…ë ¥ì—ì„œ ì£¼ì–´ì§„ ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ë“¤ì„ ì œì™¸í•œ ëª©ì ì§€ë“¤ì„ ê³µë°±ìœ¼ë¡œ ë¶„ë¦¬ì‹œí‚¨ ì˜¤ë¦„ì°¨ìˆœì˜ ì •ìˆ˜ë“¤ë¡œ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
2
5 4 2
1 2 3
1 2 6
2 3 2
3 4 4
3 5 3
5
4
6 9 2
2 3 1
1 2 1
1 3 3
2 4 4
2 5 5
3 4 3
3 6 2
4 5 4
4 6 3
5 6 7
5
6
```

**ì˜ˆì œ ì¶œë ¥1**

```
4 5
6
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
import sys
from heapq import heappush, heappop

def dijkstra(start, n, graph):
    dist = [int(21e8)] * (n + 1)
    dist[start] = 0
    heap = [(0, start)]

    while heap:
        cost, now = heappop(heap)
        if cost > dist[now]:
            continue
        for weight, nxt in graph[now]:
            if dist[nxt] > cost + weight:
                dist[nxt] = cost + weight
                heappush(heap, (cost + weight, nxt))
    return dist

T = int(sys.stdin.readline().rstrip())

for testcase in range(T):
    N, M, T = map(int, sys.stdin.readline().rstrip().split())
    S, G, H = map(int, sys.stdin.readline().rstrip().split())
    edges = [[] for _ in range(N+1)]

    for _ in range(M):
        a, b, d = map(int, sys.stdin.readline().rstrip().split())
        edges[a].append((d, b))
        edges[b].append((d, a))
    
    destinations = []
    for _ in range(T):
        x = int(sys.stdin.readline().rstrip())
        destinations.append(x)
    
    dist_s = dijkstra(S, N, edges)
    dist_g = dijkstra(G, N, edges)
    dist_h = dijkstra(H, N, edges)

    answer = []

    for destination in destinations:
        route1 = dist_s[G] + dist_g[H] + dist_h[destination]
        route2 = dist_s[H] + dist_h[G] + dist_g[destination]

        if dist_s[destination] == route1 or dist_s[destination] == route2:
            answer.append(destination)
    
    print(" ".join(map(str, sorted(answer))))
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|121180|264|PyPy3|1411
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. ë‹¤ìµìŠ¤íŠ¸ë¼
```

### **ë‹¤ë¥¸ í’€ì´**

```python
import sys
from heapq import heappush, heappop
input = sys.stdin.readline

INF = float('inf')

def dijkstra(graph, start, cnt):
    cost = [INF] * cnt
    cost[start] = 0
    cur = [(0, start)]

    while cur:
        p, x = heappop(cur)
        if p > cost[x]: continue

        for to, c in graph[x]:
            if cost[x] + c < cost[to]:
                cost[to] = cost[x] + c
                heappush(cur, (cost[to], to))
    
    return cost

def solution():
    N, M, T = map(int, input().split())
    s, g, h = map(int, input().split())
    graph = [[] for _ in range(N+1)]

    for _ in range(M):
        a, b, d = map(int, input().split())
        graph[a].append((b, d << 1))
        graph[b].append((a, d << 1))
    
    f1 = next(filter(lambda k: graph[g][k][0]==h, range(len(graph[g]))))
    f2 = next(filter(lambda k: graph[h][k][0]==g, range(len(graph[h]))))
    graph[g][f1] = (graph[g][f1][0], graph[g][f1][1] - 1)
    graph[h][f2] = (graph[h][f2][0], graph[h][f2][1] - 1)

    dest = tuple(int(input()) for _ in range(T))
    cost = dijkstra(graph, s, N+1)
    
    return ' '.join(list(map(str, sorted([ i for i in dest if cost[i] != INF and cost[i] & 1 ]))))

print('\n'.join([solution() for _ in range(int(input()))]))
```

ì•„ì´ë”” | ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B) 
:-----:|:-----:|:-----:|:----:|:--------:
amgkd9|46532|224|Python3|1240
#### **ğŸ“í•´ì„¤**

```python
import sys
from heapq import heappush, heappop

# ë‹¤ìµìŠ¤íŠ¸ë¼ íƒìƒ‰ì„ í•˜ëŠ” í•¨ìˆ˜
def dijkstra(start, n, graph): # ì‹œì‘ì , êµì°¨ë¡œì˜ ê°œìˆ˜, ê·¸ë˜í”„

    # startì—ì„œ ì‹œì‘í–ˆì„ ë•Œ, ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬
    dist = [int(21e8)] * (n + 1)
    dist[start] = 0
    heap = [(0, start)]

    while heap:
        cost, now = heappop(heap)
        if cost > dist[now]:
            continue
        for weight, nxt in graph[now]:
            if dist[nxt] > cost + weight:
                dist[nxt] = cost + weight
                heappush(heap, (cost + weight, nxt))
    
    # ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ë¦¬í„´
    return dist

T = int(sys.stdin.readline().rstrip())

for testcase in range(T):
    # ì…ë ¥ë°›ê¸°
    N, M, T = map(int, sys.stdin.readline().rstrip().split())
    S, G, H = map(int, sys.stdin.readline().rstrip().split())
    edges = [[] for _ in range(N+1)]

    for _ in range(M):
        a, b, d = map(int, sys.stdin.readline().rstrip().split())
        edges[a].append((d, b))
        edges[b].append((d, a))
    
    destinations = []
    for _ in range(T):
        x = int(sys.stdin.readline().rstrip())
        destinations.append(x)
    
    # ê°ê° S, G, Hì—ì„œ ì‹œì‘í•œ ê²½ìš° ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ì €ì¥
    dist_s = dijkstra(S, N, edges)
    dist_g = dijkstra(G, N, edges)
    dist_h = dijkstra(H, N, edges)

    answer = []

    # ë„ì°© í›„ë³´ì§€ë“¤ì„ ê²€ì‚¬í•˜ë©´ì„œ
    for destination in destinations:

        # sì—ì„œ ì¶œë°œí•´ì„œ G, Gì—ì„œ ì¶œë°œí•´ì„œ H, Hì—ì„œ ì¶œë°œí•´ì„œ ë„ì°©ì§€ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ êµ¬í•¨
        route1 = dist_s[G] + dist_g[H] + dist_h[destination]
        # Hë¥¼ ë¨¼ì € ë°©ë¬¸í•˜ëŠ” ê²½ìš°ë„ ê³ ë ¤
        route2 = dist_s[H] + dist_h[G] + dist_g[destination]

        # ì´ ê±°ë¦¬ í•©ì´ ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë©´
        if dist_s[destination] == route1 or dist_s[destination] == route2:

            # ì •ë‹µìœ¼ë¡œ ì €ì¥
            answer.append(destination)
    
    print(" ".join(map(str, sorted(answer))))
```