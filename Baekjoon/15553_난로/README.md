# [15553] 난로

### **난이도**
골드 5
## **📝문제**
구사과의 방에는 난로가 하나 있다. 구사과는 절약 정신이 투철하기 때문에, 방에 혼자 있을 때는 난로를 되도록 켜지 않는다. 구사과는 방에 친구가 왔을 때는 항상 난로를 켠다.

오늘은 N명의 친구들이 구사과의 집에 방문하는 날이다. 구사과는 친구들을 쉽게 구분하기 위해 1부터 N까지 번호를 매겼다. i번째 친구는 구사과의 방에 시간 Ti에 도착하고, 시간 Ti+1에 나간다. 구사과의 방은 좁기 때문에, 한 번에 한 명만 방문할 수 있다. 즉, 방안에는 항상 구사과를 포함해 2명 이하의 사람만 있게 된다.

구사과는 난로를 아무 때나 켤 수 있고, 끌 수 있다. 난로를 켜려면 성냥을 이용해야 한다. 오늘 구사과는 총 K개의 성냥을 가지고 있다. 따라서, 최대 K번 난로를 켤 수 있다. 가장 처음에 난로는 꺼져있다.

구사과는 난로가 켜져 있는 시간을 최소로 하려고 한다. 구사과의 친구들이 도착하는 시간과 가지고 있는 성냥의 개수가 주어졌을 때, 난로가 켜져 있는 시간의 최솟값을 구하는 프로그램을 작성하시오.
### **입력**
첫째 줄에 구사과의 집을 방문하는 친구의 수 N (1 ≤ N ≤ 100,000), 구사과가 가지고 있는 성냥의 개수 K (1 ≤ K ≤ N)이 주어진다.

둘째 줄부터 N개의 줄에는 구사과의 집을 방문하는 친구의 도착 시간 Ti가 i가 증가하는 순서대로 주어진다. (1 ≤ Ti ≤ 1,000,000,000) 동시에 두 명이 방문하는 경우는 없기 때문에, 모든 1 ≤ i ≤ N-1에 대해서 Ti < Ti+1 를 만족한다.
### **출력**
첫째 줄에 난로가 켜져 있는 시간의 최솟값을 출력한다.
### **예제입출력**

**예제 입력1**

```
3 2
1
3
6
```

**예제 출력1**

```
4
```

**예제 입력2**

```
3 1
1
2
6
```

**예제 출력2**

```
6
```

**예제 입력3**

```
3 3
1
3
6
```

**예제 출력3**

```
3
```

### **출처**

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```python
import sys

N, K = map(int, sys.stdin.readline().rstrip().split())
arr = [int(sys.stdin.readline().rstrip()) for _ in range(N)]

total_time = arr[N-1] + 1 - arr[0]
gaps = []
for i in range(N-1):
    gaps.append(arr[i+1] - arr[i] - 1)

gaps.sort(reverse=True)
off_time = sum(gaps[:K-1]) if K > 1 else 0

print(total_time - off_time)
```

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
정답|40904|112|Python3|331
#### **📝해설**

**알고리즘**
```
1. 그리디 알고리즘
```

#### **📝해설**

```python
import sys

# 입력받기
N, K = map(int, sys.stdin.readline().rstrip().split())
arr = [int(sys.stdin.readline().rstrip()) for _ in range(N)]

# 난로를 한번도 안 끈 경우 켜져있는 시간
total_time = arr[N-1] + 1 - arr[0]

# 친구들 방문 시간의 간격
gaps = []

# 친구들이 방문하는 사이에 난로를 계속 켜둔다면 이 시간만큼 켜지게 됨
for i in range(N-1):
    gaps.append(arr[i+1] - arr[i] - 1)

# 간격을 큰 순서대로 정렬
gaps.sort(reverse=True)

# 간격이 큰 순서대로 K개를 제외한다면 난로를 최소한으로 키는 경우
off_time = sum(gaps[:K-1]) if K > 1 else 0

print(total_time - off_time)
```