# [22868] μ‚°μ±… (small)

### **λ‚μ΄λ„**
κ³¨λ“ 3
## **π“λ¬Έμ **
μ½”λ΅λ‚λ΅ μΈν•μ—¬ ν™•μ°μκ°€ λλ²„λ ¤ μ¤λλ¶€ν„° μ‚°μ±…μ„ ν•λ ¤κ³  ν•λ‹¤. μ΄λ¥Ό μ„ν•΄ μ‚°μ±…ν•  κ²½λ΅λ¥Ό μ •ν•λ ¤κ³  ν•λ‹¤.

ν„μ¬ μλ” κ³³ 
$S$μ—μ„ μ¶λ°ν•μ—¬ 
$S$μ™€ λ‹¤λ¥Έ κ³³μΈ 
$E$λ¥Ό μ°κ³  λ‹¤μ‹ 
$S$λ΅ λμ•„μ¤λ” κ²½λ΅λ΅ λ§λ“¤λ ¤κ³  ν•λ‹¤. μ‚°μ±…μ„ ν•  λ• μ΄λ―Έ κ°”λ μ •μ μ„ λ κ°€κΈ° μ‹«μ–΄ 
$E$μ—μ„ 
$S$λ΅ μ¬ λ• 
$S$μ—μ„ 
$E$λ΅ κ°€λ” λ„μ¤‘μ— λ°©λ¬Έν• μ •μ μ„ μ μ™Έν• λ‹¤λ¥Έ μ •μ μΌλ΅ μ΄λ™ν•λ ¤κ³  ν•λ‹¤. λν• μ‚°μ±… κ±°λ¦¬κ°€ κΈ΄ κ²ƒμ„ μ‹«μ–΄ν•μ—¬ 
$S$μ—μ„ 
$E$λ΅ κ°€λ” κ°€μ¥ μ§§μ€ κ±°λ¦¬μ™€ 
$E$μ—μ„ 
$S$λ΅ κ°€λ” κ°€μ¥ μ§§μ€ κ±°λ¦¬λ¥Ό μ›ν•λ‹¤.

μ •μ  
$S$μ—μ„ μ •μ  
$E$λ΅ μ΄λ™ν•  λ•, κ°€μ¥ μ§§μ€ κ±°λ¦¬μ κ²½λ΅κ°€ μ—¬λ¬κ° λ‚μ¬ μ μλ‹¤. κ·Έ μ¤‘, μ •μ  
$S$μ—μ„ μ •μ  
$E$λ΅ μ΄λ™ν• κ²½λ΅λ¥Ό λ‚μ—΄ν–μ„ λ•, μ‚¬μ „μμΌλ΅ κ°€μ¥ λ¨Όμ € μ¤λ” κ²ƒμ„ μ„ νƒν•λ‹¤.

μλ¥Ό λ“¤μ–΄, μ •μ  1μ—μ„ μ •μ  2λ΅ μ΄λ™ν•λ‹¤κ³  ν–μ„ λ•, κ°€μ¥ μ§§μ€ κ±°λ¦¬μ κ²½λ΅κ°€ 1 4 3 2μ™€ 1 3 4 2κ°€ μλ‹¤κ³  κ°€μ •μ„ ν•΄λ³΄μ. λ‘ κ°μ κ²½λ΅μ¤‘ μ‚¬μ „μμΌλ΅ λ¨Όμ € μ¤λ” κ²ƒμ€ 1 3 4 2μ΄λ―€λ΅ μ •μ  1μ—μ„ μ •μ  2λ΅ κ°€λ” μµλ‹¨ κ²½λ΅ μ¤‘ λ‘ λ²μ§Έ κ²ƒμ„ μ„ νƒν•λ‹¤.

μ΄μ™€ κ°™μ΄ μ‚°μ±… κ²½λ΅λ¥Ό μ •ν•  λ•, μ‚°μ±… μ „μ²΄ κ²½λ΅μ κ±°λ¦¬(
$S$μ—μ„ 
$E$λ΅ κ°€λ” κ±°λ¦¬ + 
$E$μ—μ„ 
$S$λ΅ κ°€λ” κ±°λ¦¬)λ¥Ό κµ¬ν•΄λ³΄μ.
### **μ…λ ¥**
μ²« λ²μ§Έ μ¤„μ—λ” μ •μ μ κ°μ 
$N$κ³Ό λ‘ μ •μ  μ‚¬μ΄λ¥Ό μ‡λ” λ„λ΅μ κ°μ 
$M$μ΄ κ³µλ°±μΌλ΅ κµ¬λ¶„λμ–΄ μ£Όμ–΄μ§„λ‹¤.

λ‘ λ²μ§Έ μ¤„λ¶€ν„° 
$M + 1$ λ²μ§Έ μ¤„κΉμ§€ μ •μ  
$A$, 
$B$κ°€ κ³µλ°±μΌλ΅ κµ¬λ¶„λμ–΄ μ£Όμ–΄μ§„λ‹¤. μ •μ  
$A$μ™€ μ •μ  
$B$ μ‚¬μ΄μ κ±°λ¦¬λ” ν•­μƒ 1μ΄λ‹¤. μ΄λ•, μ •μ  
$A$μ™€ μ •μ  
$B$λ” μ–‘λ°©ν–¥μΌλ΅ μ΄λ™ν•΄λ„ λλ‹¤.

μ •μ  
$A$μ™€ μ •μ  
$B$λ¥Ό μ‡λ” λ„λ΅λ” λ‘κ° μ΄μƒ μ£Όμ–΄μ§€μ§€ μ•λ”λ‹¤.

β€
$M + 2$λ²μ§Έ μ¤„μ—λ” μ •μ  
$S$μ™€ μ •μ  
$E$κ°€ κ³µλ°±μΌλ΅ κµ¬λ¶„λμ–΄ μ£Όμ–΄μ§„λ‹¤.

μ‚°μ±…μ„ ν•  μ μλ” κ²½λ΅κ°€ μλ” λ°μ΄ν„°λ§ μ£Όμ–΄μ§„λ‹¤.
### **μ¶λ ¥**
μ‚°μ±…μ μ „μ²΄ κ²½λ΅μ κΈΈμ΄λ¥Ό μ¶λ ¥ν•λ‹¤.
### **μμ μ…μ¶λ ¥**

**μμ  μ…λ ¥1**

```
4 5
1 2
1 3
2 3
2 4
3 4
1 4
```

**μμ  μ¶λ ¥1**

```
4
```

### **μ¶μ²**

## **π§CODE REVIEW**

### **π§Ύλ‚μ ν’€μ΄**

```python
import sys
from collections import deque

N, M = map(int, sys.stdin.readline().rstrip().split())
edges = [[] for _ in range(N+1)]
for _ in range(M):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    edges[a].append(b)
    edges[b].append(a)

S, E = map(int, sys.stdin.readline().rstrip().split())

for i in range(1, N+1):
    edges[i].sort()


visited = [0] * (N+1)
q = deque([(S, 0)])
visited[S] = -1

while q:
    now, dist = q.popleft()
    if now == E:
        break

    for next_node in edges[now]:
        if not visited[next_node]:
            visited[next_node] = now
            q.append((next_node, dist + 1))
    
result = dist

now_node = E
blocked_node = set()

while now_node != S:
    before_node = visited[now_node]
    blocked_node.add(now_node)
    now_node = before_node

visited = [False] * (N+1)
q = deque([(E, 0)])
visited[E] = True

while q:
    now, dist = q.popleft()

    if now == S:
        break

    for next_node in edges[now]:
        if not visited[next_node] and next_node not in blocked_node:
            visited[next_node] = True
            q.append((next_node, dist + 1))

result += dist
print(result)
```

κ²°κ³Ό	| λ©”λ¨λ¦¬(KB) |	μ‹κ°„(ms) |	μ–Έμ–΄ |	μ½”λ“ κΈΈμ΄(B)
:----:|:-----:|:-----:|:-----:|:--------:
μ •λ‹µ|39684|128|Python3|1153
#### **π“ν•΄μ„¤**

**μ•κ³ λ¦¬μ¦**
```
1. BFS
```

### **λ‹¤λ¥Έ ν’€μ΄**

```python
import io
from collections import deque

def s():
    input = io.BufferedReader(io.FileIO(0), 1 << 16).readline

    def bfs(start, goal, adj, banned=None):
        n = len(adj) - 1
        dist, par = [-1]*(n+1), [-1]*(n+1)
        q = deque([start]); dist[start] = 0
        while q:
            u = q.popleft()
            if u == goal: break
            for v in adj[u]:
                if (banned and banned[v]) or dist[v] != -1: continue
                dist[v], par[v] = dist[u] + 1, u
                q.append(v)
        return dist, par

    N, M = map(int, input().split())
    adj = [[] for _ in range(N+1)]
    for _ in range(M):
        a, b = map(int, input().split())
        adj[a].append(b); adj[b].append(a)
    S, E = map(int, input().split())
    for u in range(1, N+1): adj[u].sort()

    d1, p1 = bfs(S, E, adj)
    path, x = [], E
    while x != -1:
        path.append(x)
        if x == S: break
        x = p1[x]
    path.reverse()

    banned = [False]*(N+1)
    for v in path[1:-1]: banned[v] = True

    d2, _ = bfs(E, S, adj, banned)
    print(d1[E] + d2[S])

s()
```

μ•„μ΄λ”” | λ©”λ¨λ¦¬(KB) |	μ‹κ°„(ms) |	μ–Έμ–΄ |	μ½”λ“ κΈΈμ΄(B) 
:-----:|:-----:|:-----:|:----:|:--------:
hanzch|38036|96|Python3|1094
#### **π“ν•΄μ„¤**

```python
import sys
from collections import deque

# μ…λ ¥λ°›κΈ°
N, M = map(int, sys.stdin.readline().rstrip().split())
edges = [[] for _ in range(N+1)]
for _ in range(M):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    edges[a].append(b)
    edges[b].append(a)

S, E = map(int, sys.stdin.readline().rstrip().split())

# μ‚¬μ „μμΌλ΅ λ°©λ¬Έν•κΈ° λ•λ¬Έμ—, κ°„μ„  μ •λ³΄λ“¤μ„ λ¨λ‘ μ¤λ¦„μ°¨μ μ •λ ¬
for i in range(1, N+1):
    edges[i].sort()

# λ°©λ¬Έ μ—¬λ¶€ λ° μ΄μ „ λ°©λ¬Έ λ…Έλ“ μ €μ¥
visited = [0] * (N+1)

# BFSλ¥Ό μ„ν• queue. (ν„μ¬ λ…Έλ“, μ΄λ™ κ±°λ¦¬)
q = deque([(S, 0)])

# μ‹μ‘λ…Έλ“λ” μ΄μ „ λ°©λ¬Έ λ…Έλ“λ¥Ό -1λ΅ μ €μ¥
visited[S] = -1

# BFS
while q:
    now, dist = q.popleft()

    # λ„μ°©ν–λ‹¤λ©΄ μΆ…λ£
    if now == E:
        break

    # λ°©λ¬Έ κ°€λ¥ν• λ‹¤μ λ…Έλ“λ“¤μ„ μ‚¬μ „μμΌλ΅ λ°©λ¬Έ
    for next_node in edges[now]:
        if not visited[next_node]:

            # μ§μ „ λ°©λ¬Έ λ…Έλ“λ¥Ό μ €μ¥
            visited[next_node] = now
            q.append((next_node, dist + 1))

# ν„μ¬ S -> EκΉμ§€ μ΄λ™ κ±°λ¦¬
result = dist

# λμ—μ„λ¶€ν„° κ²½λ΅λ¥Ό μ¶”μ ν•λ©° μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“λ“¤μ€ λ°©λ¬Έν•μ§€ μ•λ„λ΅ setλ΅ μ €μ¥
now_node = E
blocked_node = set()

while now_node != S:
    before_node = visited[now_node]
    blocked_node.add(now_node)
    now_node = before_node

# μ΄ν›„ E -> Sλ΅ λ‹¤μ‹ BFS
visited = [False] * (N+1)
q = deque([(E, 0)])
visited[E] = True

while q:
    now, dist = q.popleft()

    if now == S:
        break
    
    # μ•„κΉμ™€ λ‹¤λ¥΄κ² μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“λ” λ°©λ¬Έν•μ§€ μ•λ„λ΅ μ²λ¦¬
    for next_node in edges[now]:
        if not visited[next_node] and next_node not in blocked_node:
            visited[next_node] = True
            q.append((next_node, dist + 1))

# E -> Sλ΅ μ΄λ™ν• κ±°λ¦¬ λ”ν•΄μ¤
result += dist
print(result)
```