# [2482] 색상환

### **난이도**
골드 3
## **📝문제**
색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.


[이미지](https://upload.acmicpc.net/069ffaec-e512-4352-bbc4-5ed9a20851ee/-/preview/)
그림 1. 먼셀의 20색상환

색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.

주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.

주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.
### **입력**
입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다. 
### **출력**
첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.
### **예제입출력**

**예제 입력1**

```
4
2
```

**예제 출력1**

```
2
```

### **출처**

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```python
N = int(input())
K = int(input())

MOD = 1000000003

dp = [[0] * (K+1) for _ in range(N+1)]

for i in range(N+1):
    dp[i][0] = 1
    if i >= 1:
        dp[i][1] = i

for i in range(2, N+1):
    for j in range(2, K+1):
        dp[i][j] = (dp[i-1][j] + dp[i-2][j-1]) % MOD

answer = (dp[N-1][K] + dp[N-3][K-1]) % MOD
print(answer)
```

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
정답|45368|280|Python3|330
#### **📝해설**

**알고리즘**
```
1. DP
```

### **다른 풀이**

```python
import sys
def input():return sys.stdin.readline().rstrip()
from math import comb
def H(n, r):
    if r >= 0:
        return comb(n+r-1, r)
    else:
        return 0
n, k = int(input()), int(input())
if k * 2 > n:
    print(0)
else:
    ans = H(k, n - k - k) * 2 + H(k + 1, n - k - k - 1)
    print(ans % (10**9+3))
```

아이디 | 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:-----:|:----:|:--------:
dong5995|33240|36|Python3|316
#### **📝해설**

```python
N = int(input())
K = int(input())

MOD = 1000000003

# DP배열 선언
# dp[i][j] : i개의 색상일 때, k개 고른 경우의 수
dp = [[0] * (K+1) for _ in range(N+1)]

# 초기값 설정
for i in range(N+1):
    dp[i][0] = 1
    if i >= 1:
        dp[i][1] = i

# 점화식
for i in range(2, N+1):
    for j in range(2, K+1):
        # i번째 색을 선택하지 않는 경우의 수 : dp[i-1][j]
        # i번째 색을 선택하는 경우 : dp[i-2][j-1]
        dp[i][j] = (dp[i-1][j] + dp[i-2][j-1]) % MOD

# 원형 DP이기 때문에, 추가적인 계산이 필요함
# dp[N-1][K] : 원형에서 가장 첫번째 색깔을 칠하지 않은 경우. 2~N개중 K개를 고름
# dp[N-3][K-1] : 원형에서 가장 첫번째 색깔을 칠했을 때, 2번, N-1번 색깔은 칠할 수 없음
answer = (dp[N-1][K] + dp[N-3][K-1]) % MOD
print(answer)
```