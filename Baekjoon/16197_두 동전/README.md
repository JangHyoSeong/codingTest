# [16197] ë‘ ë™ì „

### **ë‚œì´ë„**
ê³¨ë“œ 4
## **ğŸ“ë¬¸ì œ**
NÃ—M í¬ê¸°ì˜ ë³´ë“œì™€ 4ê°œì˜ ë²„íŠ¼ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ê²Œì„ì´ ìˆë‹¤. ë³´ë“œëŠ” 1Ã—1í¬ê¸°ì˜ ì •ì‚¬ê°í˜• ì¹¸ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆê³ , ê°ê°ì˜ ì¹¸ì€ ë¹„ì–´ìˆê±°ë‚˜, ë²½ì´ë‹¤. ë‘ ê°œì˜ ë¹ˆ ì¹¸ì—ëŠ” ë™ì „ì´ í•˜ë‚˜ì”© ë†“ì—¬ì ¸ ìˆê³ , ë‘ ë™ì „ì˜ ìœ„ì¹˜ëŠ” ë‹¤ë¥´ë‹¤.

ë²„íŠ¼ì€ "ì™¼ìª½", "ì˜¤ë¥¸ìª½", "ìœ„", "ì•„ë˜"ì™€ ê°™ì´ 4ê°€ì§€ê°€ ìˆë‹¤. ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë‘ ë™ì „ì´ ë²„íŠ¼ì— ì“°ì—¬ ìˆëŠ” ë°©í–¥ìœ¼ë¡œ ë™ì‹œì— ì´ë™í•˜ê²Œ ëœë‹¤.

- ë™ì „ì´ ì´ë™í•˜ë ¤ëŠ” ì¹¸ì´ ë²½ì´ë©´, ë™ì „ì€ ì´ë™í•˜ì§€ ì•ŠëŠ”ë‹¤.  
- ë™ì „ì´ ì´ë™í•˜ë ¤ëŠ” ë°©í–¥ì— ì¹¸ì´ ì—†ìœ¼ë©´ ë™ì „ì€ ë³´ë“œ ë°”ê¹¥ìœ¼ë¡œ ë–¨ì–´ì§„ë‹¤.  
- ê·¸ ì™¸ì˜ ê²½ìš°ì—ëŠ” ì´ë™í•˜ë ¤ëŠ” ë°©í–¥ìœ¼ë¡œ í•œ ì¹¸ ì´ë™í•œë‹¤.ì´ë™í•˜ë ¤ëŠ” ì¹¸ì— ë™ì „ì´ ìˆëŠ” ê²½ìš°ì—ë„ í•œ ì¹¸ ì´ë™í•œë‹¤.  
ë‘ ë™ì „ ì¤‘ í•˜ë‚˜ë§Œ ë³´ë“œì—ì„œ ë–¨ì–´ëœ¨ë¦¬ê¸° ìœ„í•´ ë²„íŠ¼ì„ ìµœì†Œ ëª‡ ë²ˆ ëˆŒëŸ¬ì•¼í•˜ëŠ”ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
### **ì…ë ¥**
ì²«ì§¸ ì¤„ì— ë³´ë“œì˜ ì„¸ë¡œ í¬ê¸° Nê³¼ ê°€ë¡œ í¬ê¸° Mì´ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ N, M â‰¤ 20)

ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ë³´ë“œì˜ ìƒíƒœê°€ ì£¼ì–´ì§„ë‹¤.

- o: ë™ì „
- .: ë¹ˆ ì¹¸
- #: ë²½  
ë™ì „ì˜ ê°œìˆ˜ëŠ” í•­ìƒ 2ê°œì´ë‹¤.
### **ì¶œë ¥**
ì²«ì§¸ ì¤„ì— ë‘ ë™ì „ ì¤‘ í•˜ë‚˜ë§Œ ë³´ë“œì—ì„œ ë–¨ì–´ëœ¨ë¦¬ê¸° ìœ„í•´ ëˆŒëŸ¬ì•¼ í•˜ëŠ” ë²„íŠ¼ì˜ ìµœì†Œ íšŸìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤. ë§Œì•½, ë‘ ë™ì „ì„ ë–¨ì–´ëœ¨ë¦´ ìˆ˜ ì—†ê±°ë‚˜, ë²„íŠ¼ì„ 10ë²ˆë³´ë‹¤ ë§ì´ ëˆŒëŸ¬ì•¼ í•œë‹¤ë©´, -1ì„ ì¶œë ¥í•œë‹¤.
### **ì˜ˆì œì…ì¶œë ¥**

**ì˜ˆì œ ì…ë ¥1**

```
1 2
oo
```

**ì˜ˆì œ ì¶œë ¥1**

```
1
```

**ì˜ˆì œ ì…ë ¥2**

```
6 2
.#
.#
.#
o#
o#
##
```

**ì˜ˆì œ ì¶œë ¥2**

```
4
```

**ì˜ˆì œ ì…ë ¥3**

```
6 2
..
..
..
o#
o#
##
```

**ì˜ˆì œ ì¶œë ¥3**

```
3
```

### **ì¶œì²˜**

## **ğŸ§CODE REVIEW**

### **ğŸ§¾ë‚˜ì˜ í’€ì´**

```python
from collections import deque

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

N, M = map(int, input().split())
board = [list(input().strip()) for _ in range(N)]

coins = []
for i in range(N):
    for j in range(M):
        if board[i][j] == 'o':
            coins.append((i, j))

q = deque([(coins[0][0], coins[0][1], coins[1][0], coins[1][1], 0)])
visited = set([(coins[0][0], coins[0][1], coins[1][0], coins[1][1])])

while q:
    x1, y1, x2, y2, count = q.popleft()
    
    if count >= 10:
        break
    
    for i in range(4):
        nx1, ny1 = x1 + dx[i], y1 + dy[i]
        nx2, ny2 = x2 + dx[i], y2 + dy[i]
        
        out1 = not (0 <= nx1 < N and 0 <= ny1 < M)
        out2 = not (0 <= nx2 < N and 0 <= ny2 < M)
        
        if out1 and out2:
            continue
        if out1 or out2:
            print(count + 1)
            exit()
        
        if not out1 and board[nx1][ny1] == '#':
            nx1, ny1 = x1, y1
        if not out2 and board[nx2][ny2] == '#':
            nx2, ny2 = x2, y2
        
        if (nx1, ny1, nx2, ny2) not in visited:
            visited.add((nx1, ny1, nx2, ny2))
            q.append((nx1, ny1, nx2, ny2, count + 1))

print(-1)
```

ê²°ê³¼	| ë©”ëª¨ë¦¬(KB) |	ì‹œê°„(ms) |	ì–¸ì–´ |	ì½”ë“œ ê¸¸ì´(B)
:----:|:-----:|:-----:|:-----:|:--------:
ì •ë‹µ|35016|64|Python3|1184
#### **ğŸ“í•´ì„¤**

**ì•Œê³ ë¦¬ì¦˜**
```
1. BFS
```

#### **ğŸ“í•´ì„¤**

```python
from collections import deque

# ìƒí•˜ì¢Œìš° ì´ë™ì„ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

N, M = map(int, input().split())
board = [list(input().strip()) for _ in range(N)]

# ì´ˆê¸° ë™ì „ì˜ ìœ„ì¹˜ë¥¼ ì…ë ¥
coins = []
for i in range(N):
    for j in range(M):
        if board[i][j] == 'o':
            coins.append((i, j))

# BFSë¥¼ ìœ„í•œ queue, ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì €ì¥í•  ì§‘í•©ì„ í•˜ë‚˜ ì •ì˜
q = deque([(coins[0][0], coins[0][1], coins[1][0], coins[1][1], 0)]) # x1, y1, x2, y2, ì´ë™íšŸìˆ˜
visited = set([(coins[0][0], coins[0][1], coins[1][0], coins[1][1])])

# BFS ì‹œì‘
while q:
    x1, y1, x2, y2, count = q.popleft()
    
    # ì´ë™íšŸìˆ˜ê°€ 10ë²ˆì„ ë„˜ìœ¼ë©´ ì¢…ë£Œ
    if count >= 10:
        break
    
    # ìƒí•˜ì¢Œìš°ë¥¼ íƒìƒ‰
    for i in range(4):

        # ìƒˆë¡œìš´ ì¢Œí‘œ ì •ì˜
        nx1, ny1 = x1 + dx[i], y1 + dy[i]
        nx2, ny2 = x2 + dx[i], y2 + dy[i]
        
        # ë³´ë“œë¥¼ ë²—ì–´ë‚˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì €ì¥
        out1 = not (0 <= nx1 < N and 0 <= ny1 < M)
        out2 = not (0 <= nx2 < N and 0 <= ny2 < M)

        # ë‘˜ë‹¤ ë²—ì–´ë‚œë‹¤ë©´ X        
        if out1 and out2:
            continue

        # í•˜ë‚˜ë§Œ ë²—ì–´ë‚œë‹¤ë©´ ì¶œë ¥ í›„ ì¢…ë£Œ
        if out1 or out2:
            print(count + 1)
            exit()
        
        # ë²½ì— ë§‰íŒë‹¤ë©´ í•˜ë‚˜ë§Œ ì´ë™
        if not out1 and board[nx1][ny1] == '#':
            nx1, ny1 = x1, y1
        if not out2 and board[nx2][ny2] == '#':
            nx2, ny2 = x2, y2
        
        # ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¼€ì´ìŠ¤ë¼ë©´ ìƒˆë¡­ê²Œ ë°©ë¬¸
        if (nx1, ny1, nx2, ny2) not in visited:
            visited.add((nx1, ny1, nx2, ny2))
            q.append((nx1, ny1, nx2, ny2, count + 1))

# 10ë²ˆ ì´ë‚´ë¡œ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´ -1 ì¶œë ¥
print(-1)
```